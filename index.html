<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>E-casso Lab</title>

  <!-- Three.jsï¼ˆå…¨åŸŸï¼‰ -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
    }

    #idle    { z-index: 1; }
    #loading { z-index: 2; }
    #cosmos  { z-index: 3; }
    #final   { z-index: 4; }

    .screen {
      display: none;
      position: fixed;
      inset: 0;
      align-items: center;
      justify-content: center;
    }

    .screen.active {
      display: flex;
    }

    /* ================= IDLE ================= */
    #idle {
      background-image: url("./bg_idle.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: contain;
      background-color: black;
    }

    #scan-overlay {
      position: absolute;
      left: 30%;
      top: 72%;
      width: 36%;
      height: 18%;
      overflow: hidden;
      pointer-events: none;
    }

    #scan-overlay video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.9;
    }

    .scan-line {
      position: absolute;
      top: -30%;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.7), transparent);
      animation: scanMove 2.5s linear infinite;
    }

    @keyframes scanMove {
      from { top: -30%; }
      to   { top: 100%; }
    }

    /* ================= LOADING ================= */
    .loading-container {
      width: 60%;
      max-width: 800px;
      color: #7ffcff;
      font-family: monospace;
    }

    .progress-bar {
      width: 100%;
      height: 16px;
      border: 1px solid #7ffcff;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, transparent, #7ffcff, transparent);
      transition: width 0.6s ease;
    }

    /* ================= COSMOS ================= */
    #cosmos.active {
      display: block;
      background: black;
    }

    #cosmos canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    #cosmos-hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #7ffcff;
      font-size: 14px;
      color: #7ffcff;
      font-family: monospace;
      display: none;
    }

    #cosmos.active #cosmos-hud {
      display: block;
    }

    .hud-value {
      font-weight: bold;
      color: #7ffcff;
    }

    #gesture-status {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff0000;
      margin-right: 8px;
      animation: blink 1s infinite;
    }

    #gesture-status.ready {
      background: #00ff00;
      animation: none;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    #cosmos-camera {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 160px;
      height: 120px;
      transform: scaleX(-1);
      opacity: 0.3;
      border: 1px solid #7ffcff;
      z-index: 10;
      display: none;
    }

    #cosmos.active #cosmos-camera {
      display: block;
    }

    #debug {
      position: fixed;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #888;
      z-index: 9999;
    }

    /* ================= FINAL ================= */
    #final {
      background: url("./final_bg.png") center center / contain no-repeat;
      color: #7ffcff;
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    #final.active {
      display: block !important;
    }

    #final {
      align-items: unset !important;
      justify-content: unset !important;
    }

    .final-left {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .bio-slot {
      position: absolute;
      overflow: hidden;
    }

    .bio-slot canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .bio-slot-1 {
      left: 350px;
      top: 240px;
      width: 320px;
      height: 150px;
    }

    .bio-slot-2 {
      left: 350px;
      top: 430px;
      width: 320px;
      height: 200px;
    }

    .bio-slot-3 {
      left: 330px;
      top: 688px;
      width: 260px;
      height: 120px;
    }

    .final-center {
      position: absolute;
      left: 22%;
      top: 0;
      width: 52%;
      height: 100%;
      pointer-events: none;
    }

    .final-right {
      position: absolute !important;
      top: 180px;
      right: 289px;
      width: 380px;
      height: 580px; /* âœ… å›ºå®šé«˜åº¦ */
      color: #7ffcff;
      font-family: monospace;
      text-shadow: 0 0 8px rgba(0,255,255,0.25);
      display: flex;
      flex-direction: column;
    }

    .final-right h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
      letter-spacing: 2px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0; /* âœ… ä¸å£“ç¸® */
    }

    .final-right .color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
    }

    .final-right .item-name {
      font-size: 22px;
      font-weight: bold;
      margin: 15px 0;
      letter-spacing: 1px;
      flex-shrink: 0; /* âœ… ä¸å£“ç¸® */
    }

    .final-right p {
      margin-top: 18px;
      font-size: 16px;
      line-height: 1.8;
      white-space: pre-wrap;
      word-wrap: break-word; /* âœ… å¼·åˆ¶æ›è¡Œ */
      overflow-wrap: break-word; /* âœ… å¼·åˆ¶æ›è¡Œ */
      /* âœ… é™åˆ¶æ–‡å­—ä¸è¶…å‡ºæ¡†æ¡† */
      flex: 1; /* âœ… å¡«æ»¿å‰©é¤˜ç©ºé–“ */
      overflow-y: auto;
      overflow-x: hidden; /* âœ… éš±è—æ©«å‘æ²è»¸ */
      padding-right: 10px;
      max-width: 100%; /* âœ… ä¸è¶…å‡ºçˆ¶å®¹å™¨ */
    }

    /* âœ… è‡ªè¨‚æ²è»¸æ¨£å¼ */
    .final-right p::-webkit-scrollbar {
      width: 6px;
    }

    .final-right p::-webkit-scrollbar-track {
      background: rgba(127, 252, 255, 0.1);
    }

    .final-right p::-webkit-scrollbar-thumb {
      background: rgba(127, 252, 255, 0.5);
      border-radius: 3px;
    }
  </style>
</head>

<body>

  <!-- IDLE -->
  <div id="idle" class="screen active">
    <div id="scan-overlay">
      <video id="camera" autoplay muted playsinline></video>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="loading" class="screen">
    <div class="loading-container">
      <div id="loading-text">åˆå§‹åŒ–ä¸­â€¦</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div id="progress-percent">0%</div>
    </div>
  </div>

  <!-- COSMOS -->
  <div id="cosmos" class="screen">
    <div id="cosmos-hud">
      <div><span id="gesture-status"></span>æ‰‹å‹¢: <span id="gesture" class="hud-value">ç­‰å¾…ä¸­...</span></div>
      <div>æ‰‹æŒ‡æ•¸: <span id="fingers" class="hud-value">0</span></div>
      <div>æ¨¡å¼: <span id="mode" class="hud-value">è§’è‰²é¡¯ç¤º</span></div>
    </div>
    <video id="cosmos-camera" autoplay muted playsinline></video>
  </div>

  <!-- FINAL -->
  <div id="final" class="screen">
    <div class="final-left">
      <div class="bio-slot bio-slot-1"><canvas id="dnaCanvas"></canvas></div>
      <div class="bio-slot bio-slot-2"><canvas id="gridCanvas"></canvas></div>
      <div class="bio-slot bio-slot-3"><canvas id="heartCanvas"></canvas></div>
    </div>
    <div class="final-center"></div>
    <div class="final-right">
      <h2>
        <span id="final-color-code">#F98520</span>
        <span class="color-dot" id="final-color-dot"></span>
      </h2>
      <div class="item-name" id="final-item">å£çˆå…§çš„ç«</div>
      <p id="final-text">è¼‰å…¥ä¸­...</p>
    </div>
  </div>

  <div id="debug">state: â€”</div>

  <script type="module">
    const THREE = window.THREE;

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    
    const app = initializeApp({
      apiKey: "AIzaSyAoH3O3t8SYirmcCPVDG19bVC_Nh2VrAQc",
      authDomain: "e-casso-lab.firebaseapp.com",
      databaseURL: "https://e-casso-lab-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "e-casso-lab",
      storageBucket: "e-casso-lab.firebasestorage.app",
      messagingSenderId: "338061345474",
      appId: "1:338061345474:web:60a9b6c2a6d03e131e715b"
    });
    const db = getDatabase(app);

    const STATES = {
      IDLE: "IDLE",
      LOADING: "LOADING",
      COSMOS: "COSMOS",
      FINAL: "FINAL"
    };

    /* ================= FINAL CHARACTER (globals) ================= */
    let finalScene = null;
    let finalCamera = null;
    let finalRenderer = null;
    let finalParticles = null;
    let finalTargets = [];
    let finalRAF = null;
    let finalAnimating = false;

    /* ================= é¡é ­ ================= */
    let camStream = null;
    const video = document.getElementById("camera");

    function startCamera() {
      if (camStream) return;
      navigator.mediaDevices.getUserMedia({ video:true }).then(s=>{
        camStream = s;
        video.srcObject = s;
      }).catch(err=>{
        console.warn("camera error:", err);
      });
    }

    function stopCamera() {
      if (!camStream) return;
      camStream.getTracks().forEach(t=>t.stop());
      camStream = null;
      video.srcObject = null;
    }

    /* ================= æ‰‹å‹¢è¿½è¹¤è®Šæ•¸ ================= */
    let cosmosHandStream = null;
    let cosmosHands = null;
    let cosmosCamera = null;
    let handData = null;
    let scatterTargets = [];
    let gatherPoint = null;
    let gestureState = "WAITING"; // âœ… æ–°å¢ç‹€æ…‹: WAITING, ACTIVATED, READY

    /* ================= COSMOS ================= */
    let scene, camera3D, renderer, particles;
    let animating = false;
    let colorHex = "#66ffff";
    let characterTargets = [];
    let morphStrength = 0;
    let rafId = null;

    /* ================= æ‰‹å‹¢åµæ¸¬å‡½æ•¸ ================= */
    function countFingers(landmarks) {
      let count = 0;
      
      if (landmarks[8].y < landmarks[6].y) count++;
      if (landmarks[12].y < landmarks[10].y) count++;
      if (landmarks[16].y < landmarks[14].y) count++;
      if (landmarks[20].y < landmarks[18].y) count++;
      
      const wrist = landmarks[0];
      const indexMCP = landmarks[5];
      const thumbTip = landmarks[4];
      const scale = Math.hypot(indexMCP.x - wrist.x, indexMCP.y - wrist.y);
      const thumbDist = Math.hypot(thumbTip.x - indexMCP.x, thumbTip.y - indexMCP.y);
      
      if (thumbDist > scale * 0.5) count++;
      
      return count;
    }

    let handDetectionActive = false; // âœ… è¿½è¹¤æ˜¯å¦çœŸçš„åœ¨åµæ¸¬

    function onHandResults(results) {
      // âœ… åªè¦æ”¶åˆ°çµæœå°±ä»£è¡¨çœŸçš„åœ¨é‹ä½œ
      if (!handDetectionActive) {
        handDetectionActive = true;
        console.log("âœ…âœ…âœ… æ‰‹å‹¢åµæ¸¬å¯¦éš›é–‹å§‹é‹ä½œ!");
        
        const statusDot = document.getElementById('gesture-status');
        if (statusDot) {
          statusDot.classList.add('ready');
          statusDot.style.background = '#00ff00';
          statusDot.style.animation = 'none';
        }
      }
      
      handData = null;
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const fingerCount = countFingers(landmarks);
        handData = { landmarks, fingerCount };
        
        document.getElementById('fingers').innerText = fingerCount;
        
        // âœ… ç‹€æ…‹æ©Ÿé‚è¼¯
        if (gestureState === "WAITING") {
          if (fingerCount === 5) {
            gestureState = "ACTIVATED";
            document.getElementById('gesture').innerText = 'âœ“ åµæ¸¬æˆåŠŸ';
            document.getElementById('mode').innerText = 'è«‹æ¡æ‹³é¡¯ç¤ºè§’è‰²';
            morphStrength = 0;
          } else {
            document.getElementById('gesture').innerText = 'è«‹å¼µé–‹æ‰‹æŒ';
            document.getElementById('mode').innerText = '(5æ ¹æ‰‹æŒ‡å•Ÿå‹•)';
            morphStrength = 0;
          }
        } 
        else if (gestureState === "ACTIVATED") {
          if (fingerCount === 5) {
            document.getElementById('gesture').innerText = 'å¼µé–‹æ‰‹æŒ';
            document.getElementById('mode').innerText = 'ç²’å­åˆ†æ•£';
            setScatterMode();
          } else if (fingerCount === 0) {
            document.getElementById('gesture').innerText = 'æ¡æ‹³';
            document.getElementById('mode').innerText = 'é¡¯ç¤ºè§’è‰²';
            morphStrength = 1;
          } else {
            document.getElementById('gesture').innerText = `${fingerCount}æ ¹æ‰‹æŒ‡`;
            document.getElementById('mode').innerText = '(ç¶­æŒç•¶å‰ç‹€æ…‹)';
          }
        }
      } else {
        document.getElementById('fingers').innerText = '0';
        
        if (gestureState === "WAITING") {
          document.getElementById('gesture').innerText = 'è«‹å¼µé–‹æ‰‹æŒ';
          document.getElementById('mode').innerText = '(5æ ¹æ‰‹æŒ‡å•Ÿå‹•)';
          morphStrength = 0;
        } else {
          document.getElementById('gesture').innerText = 'æœªåµæ¸¬åˆ°æ‰‹';
          document.getElementById('mode').innerText = '(ç¶­æŒç•¶å‰ç‹€æ…‹)';
        }
      }
    }

    function setScatterMode() {
      const w = window.innerWidth * 1.2;
      const h = window.innerHeight * 1.2;
      const d = 800;
      
      if (scatterTargets.length === 0) {
        for (let i = 0; i < 24000; i++) {
          scatterTargets.push({
            x: (Math.random() - 0.5) * w,
            y: (Math.random() - 0.5) * h,
            z: (Math.random() - 0.5) * d
          });
        }
      }
      
      morphStrength = 0;
    }

    function setGatherMode() {
      if (!handData || !particles) return;
      
      const vFOV = THREE.MathUtils.degToRad(camera3D.fov);
      const heightAtZ0 = 2 * Math.tan(vFOV / 2) * camera3D.position.z;
      const widthAtZ0 = heightAtZ0 * camera3D.aspect;
      
      const palmCenter = handData.landmarks[9];
      const centerX = -(palmCenter.x - 0.5) * widthAtZ0;
      const centerY = -(palmCenter.y - 0.5) * heightAtZ0;
      
      morphStrength = -1;
      gatherPoint = { x: centerX, y: centerY, z: 0 };
    }

    function startCosmosHandTracking() {
      if (cosmosHands) {
        console.log("âš ï¸ æ‰‹å‹¢è¿½è¹¤å·²å­˜åœ¨,å…ˆåœæ­¢");
        stopCosmosHandTracking();
      }
      
      const videoElement = document.getElementById('cosmos-camera');
      
      if (!videoElement) {
        console.error("âŒ cosmos-camera å…ƒç´ ä¸å­˜åœ¨");
        return;
      }
      
      console.log("ğŸ“· [1/4] é–‹å§‹åˆå§‹åŒ–æ‰‹å‹¢è¿½è¹¤...");
      handDetectionActive = false; // âœ… é‡ç½®æ¨™è¨˜
      
      // âœ… æ›´æ–°ç‹€æ…‹æŒ‡ç¤ºç‡ˆç‚ºè¼‰å…¥ä¸­
      const statusDot = document.getElementById('gesture-status');
      if (statusDot) {
        statusDot.classList.remove('ready');
        statusDot.style.background = '#ffaa00';
        statusDot.style.animation = 'blink 0.5s infinite';
      }
      
      navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: 640, 
          height: 480,
          facingMode: "user"
        } 
      })
        .then(stream => {
          cosmosHandStream = stream;
          videoElement.srcObject = stream;
          
          console.log("ğŸ“· [2/4] æ”å½±æ©Ÿå·²å•Ÿå‹•");
          
          // âœ… ç­‰å¾… video çœŸçš„é–‹å§‹æ’­æ”¾
          return new Promise((resolve) => {
            videoElement.onloadedmetadata = () => {
              videoElement.play();
              console.log("ğŸ“· [3/4] å½±ç‰‡é–‹å§‹æ’­æ”¾");
              resolve();
            };
          });
        })
        .then(() => {
          // âœ… åˆå§‹åŒ– MediaPipe Hands
          cosmosHands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
          });
          
          cosmosHands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
          });
          
          cosmosHands.onResults(onHandResults);
          
          console.log("ğŸ“· [4/4] å•Ÿå‹• MediaPipe Camera...");
          
          cosmosCamera = new Camera(videoElement, {
            onFrame: async () => {
              if (cosmosHands) {
                await cosmosHands.send({ image: videoElement });
              }
            },
            width: 640,
            height: 480
          });
          
          cosmosCamera.start();
          console.log("âœ… Camera.start() å·²å‘¼å«,ç­‰å¾…å¯¦éš›åµæ¸¬...");
        })
        .catch(err => {
          console.error("âŒ æ‰‹å‹¢è¿½è¹¤åˆå§‹åŒ–å¤±æ•—:", err);
        });
    }

    function stopCosmosHandTracking() {
      console.log("ğŸ›‘ åœæ­¢æ‰‹å‹¢è¿½è¹¤...");
      
      handDetectionActive = false;
      
      if (cosmosHandStream) {
        cosmosHandStream.getTracks().forEach(t => t.stop());
        cosmosHandStream = null;
      }
      if (cosmosCamera) {
        cosmosCamera.stop();
        cosmosCamera = null;
      }
      cosmosHands = null;
      handData = null;
      const videoElement = document.getElementById('cosmos-camera');
      if (videoElement) {
        videoElement.srcObject = null;
        videoElement.onloadedmetadata = null;
      }
      
      // âœ… é‡ç½®ç‹€æ…‹æŒ‡ç¤ºç‡ˆ
      const statusDot = document.getElementById('gesture-status');
      if (statusDot) {
        statusDot.classList.remove('ready');
        statusDot.style.background = '#ff0000';
        statusDot.style.animation = 'blink 1s infinite';
      }
      
      console.log("âŒ æ‰‹å‹¢è¿½è¹¤å·²å®Œå…¨åœæ­¢");
    }

    /* ================= COSMOS åˆå§‹åŒ– ================= */
    function initCosmos() {
      if (scene) return;

      console.log("åˆå§‹åŒ– COSMOS...");

      scene = new THREE.Scene();
      camera3D = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
      camera3D.position.z = 350;

      renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 1);

      const cosmosEl = document.getElementById("cosmos");
      
      // âœ… ä¿®æ­£ï¼šä¿ç•™ HUD å’Œæ”å½±æ©Ÿ,åªæ’å…¥ canvas
      const existingCanvas = cosmosEl.querySelector('canvas');
      if (existingCanvas) existingCanvas.remove();
      
      cosmosEl.insertBefore(renderer.domElement, cosmosEl.firstChild);

      const count = 24000;
      const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        pos[i*3]=(Math.random()-0.5)*500;
        pos[i*3+1]=(Math.random()-0.5)*500;
        pos[i*3+2]=(Math.random()-0.5)*500;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

      const mat = new THREE.PointsMaterial({
        color:new THREE.Color(colorHex),
        size:1.3,
        transparent:true,
        opacity:0.85,
        blending:THREE.AdditiveBlending
      });

      particles = new THREE.Points(geo,mat);
      scene.add(particles);

      console.log("ç²’å­ç³»çµ±å»ºç«‹å®Œæˆ");

      loadCharacterPoints("./character.png").then(() => {
        console.log("è§’è‰²é»é›²æº–å‚™å®Œæˆï¼Œé–‹å§‹å‹•ç•«");
        if (animating) startAnimateLoop();
      }).catch(() => {
        console.warn("è§’è‰²é»é›²å¤±æ•—ï¼ˆä»å¯é¡¯ç¤ºæ¼‚æµ®ç²’å­ï¼‰");
        if (animating) startAnimateLoop();
      });
    }

    function loadCharacterPoints(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = src;

        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          const targetSize = 160;
          canvas.width = targetSize;
          canvas.height = targetSize;
          ctx.drawImage(img, 0, 0, targetSize, targetSize);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          characterTargets = [];
          const displayScale = 280;

          for(let y=0; y<canvas.height; y++){
            for(let x=0; x<canvas.width; x++){
              const i=(y*canvas.width+x)*4;
              const r = data[i], g = data[i+1], b = data[i+2], alpha = data[i+3];

              const brightness = (r + g + b) / 3;
              const isFace = brightness > 100;

              if ((isFace && alpha > 5) || (!isFace && alpha > 30)) {
                const baseX = (x / canvas.width - 0.5) * displayScale;
                const baseY = -(y / canvas.height - 0.5) * displayScale;

                characterTargets.push({ x: baseX, y: baseY, z: 0 });

                if (isFace && alpha > 50) {
                  if (Math.random() > 0.2) characterTargets.push({ x: baseX + (Math.random()-0.5)*2.5, y: baseY + (Math.random()-0.5)*2.5, z: (Math.random()-0.5)*12 });
                  if (Math.random() > 0.3) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.0, y: baseY + (Math.random()-0.5)*3.0, z: (Math.random()-0.5)*15 });
                  if (brightness > 150 && Math.random() > 0.4) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.5, y: baseY + (Math.random()-0.5)*3.5, z: (Math.random()-0.5)*18 });
                } else if (!isFace && alpha > 200 && Math.random() > 0.7) {
                  characterTargets.push({ x: baseX + (Math.random()-0.5)*1.5, y: baseY + (Math.random()-0.5)*1.5, z: (Math.random()-0.5)*6 });
                }
              }
            }
          }

          console.log(`å¾åœ–ç‰‡ç”Ÿæˆ ${characterTargets.length} å€‹ç›®æ¨™é»`);
          resolve();
        };

        img.onerror = (e) => {
          console.error("åœ–ç‰‡è¼‰å…¥å¤±æ•—:", src, e);
          reject(e);
        };
      });
    }

    function startAnimateLoop() {
      if (rafId) cancelAnimationFrame(rafId);

      const loop = () => {
        if (!animating || !particles) return;

        const p = particles.geometry.attributes.position.array;
        const time = Date.now() * 0.0003;

        if (morphStrength === -1 && gatherPoint) {
          for (let i = 0; i * 3 < p.length; i++) {
            const idx = i * 3;
            const noise = 80;
            
            const tx = gatherPoint.x + (Math.random() - 0.5) * noise;
            const ty = gatherPoint.y + (Math.random() - 0.5) * noise;
            const tz = gatherPoint.z + (Math.random() - 0.5) * noise;
            
            p[idx]     += (tx - p[idx]) * 0.12;
            p[idx + 1] += (ty - p[idx + 1]) * 0.12;
            p[idx + 2] += (tz - p[idx + 2]) * 0.12;
          }
        }
        else if (morphStrength === 0 && scatterTargets.length > 0) {
          for (let i = 0; i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = scatterTargets[i] || scatterTargets[0];
            
            p[idx]     += (t.x - p[idx]) * 0.08;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.08;
            p[idx + 2] += (t.z - p[idx + 2]) * 0.08;
          }
        }
        else if (morphStrength === 1 && characterTargets.length > 0) {
          for (let i = 0; i < characterTargets.length && i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = characterTargets[i];
            const breathe = Math.sin(time + i * 0.01) * 0.3;

            p[idx]     += (t.x - p[idx])     * 0.06;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.06;
            p[idx + 2] += (t.z + breathe - p[idx + 2]) * 0.06;
          }

          for (let i = characterTargets.length; i * 3 < p.length; i++) {
            const idx = i * 3;
            p[idx]     += Math.sin(time + i * 0.1) * 0.04;
            p[idx + 1] += Math.cos(time + i * 0.15) * 0.04;
            p[idx + 2] += Math.sin(time + i * 0.2) * 0.04;
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.002;

        renderer.render(scene, camera3D);
        rafId = requestAnimationFrame(loop);
      };

      rafId = requestAnimationFrame(loop);
    }

    /* ================= FINAL å‹•ç•« ================= */
    function startDNA(){
      const c = document.getElementById("dnaCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      let t = 0;
      function loop(){
        ctx.clearRect(0,0,c.width,c.height);
        ctx.strokeStyle = "#7ffcff";
        ctx.lineWidth = 1;

        for(let y=0; y<c.height; y+=3){
          const wave = Math.sin(y*0.05 + t) * 30;
          ctx.beginPath();
          ctx.moveTo(c.width/2 + wave, y);
          ctx.lineTo(c.width/2 - wave, y);
          ctx.stroke();
        }

        t += 0.03;
        requestAnimationFrame(loop);
      }
      loop();
    }

    function startGrid(){
      const c = document.getElementById("gridCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      const dots = Array.from({length:100},()=>({
        x: Math.random()*c.width,
        y: Math.random()*c.height,
        a: Math.random()
      }));

      function loop(){
        ctx.clearRect(0,0,c.width,c.height);

        ctx.strokeStyle = "rgba(127,252,255,0.15)";
        for(let x=0;x<c.width;x+=20){
          ctx.beginPath();
          ctx.moveTo(x,0);
          ctx.lineTo(x,c.height);
          ctx.stroke();
        }
        for(let y=0;y<c.height;y+=20){
          ctx.beginPath();
          ctx.moveTo(0,y);
          ctx.lineTo(c.width,y);
          ctx.stroke();
        }

        dots.forEach(d=>{
          d.a += (Math.random()-0.5)*0.1;
          d.a = Math.max(0,Math.min(1,d.a));
          ctx.fillStyle = `rgba(127,252,255,${d.a})`;
          ctx.fillRect(d.x,d.y,2,2);
        });

        requestAnimationFrame(loop);
      }
      loop();
    }

    function startHeartbeat(){
      const c = document.getElementById("heartCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      let t = 0;
      function loop(){
        ctx.clearRect(0,0,c.width,c.height);
        ctx.strokeStyle = "#7ffcff";
        ctx.lineWidth = 2;
        ctx.beginPath();

        for(let x=0;x<c.width;x++){
          let y =
            c.height/2 +
            Math.sin((x+t)*0.05)*8 +
            (x%120<10 ? -25 : 0);

          ctx.lineTo(x,y);
        }

        ctx.stroke();
        t += 4;
        requestAnimationFrame(loop);
      }
      loop();
    }

    /* ================= LOADING ================= */
    function startLoadingSequence() {
      const steps=[
        {t:"åˆå§‹åŒ–ä¸­â€¦",p:10},
        {t:"å§“åæ ¸å°ä¸­",p:40},
        {t:"è³‡æ–™ç¢ºèªä¸­",p:75},
        {t:"æº–å‚™å®Œæˆ",p:100}
      ];
      let i=0;
      const txt=document.getElementById("loading-text");
      const fill=document.getElementById("progress-fill");
      const per=document.getElementById("progress-percent");

      fill.style.width="0%";
      per.textContent="0%";

      function next(){
        if(i>=steps.length)return;
        txt.textContent=steps[i].t;
        fill.style.width=steps[i].p+"%";
        per.textContent=steps[i].p+"%";
        i++;
        setTimeout(next,600);
      }
      setTimeout(next,150);
    }

    /* ================= FINAL è§’è‰² ================= */
    function initFinalCharacter() {
      if (finalScene) return;

      finalScene = new THREE.Scene();
      finalCamera = new THREE.PerspectiveCamera(50, 1, 1, 1000);
      finalCamera.position.z = 180;

      finalRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      finalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const container = document.querySelector(".final-center");
      const w = container.clientWidth;
      const h = container.clientHeight;

      finalRenderer.setSize(w, h);
      finalCamera.aspect = w / h;
      finalCamera.updateProjectionMatrix();

      container.innerHTML = "";
      container.appendChild(finalRenderer.domElement);

      loadFinalCharacterPoints("./character.png").then(() => {
        const body = [];
        const face = [];

        finalTargets.forEach(t => {
          if (t.face) face.push(t);
          else body.push(t);
        });

        const bodyPos = new Float32Array(body.length * 3);
        body.forEach((t, i) => {
          bodyPos[i*3]   = t.x + 25;
          bodyPos[i*3+1] = t.y + 40;
          bodyPos[i*3+2] = t.z;
        });

        const bodyGeo = new THREE.BufferGeometry();
        bodyGeo.setAttribute("position", new THREE.BufferAttribute(bodyPos, 3));

        const bodyMat = new THREE.PointsMaterial({
          color: new THREE.Color(colorHex), // âœ… ä½¿ç”¨ç•¶å‰é¡è‰²
          size: 0.7,
          transparent: true,
          opacity: 0.55,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const bodyPoints = new THREE.Points(bodyGeo, bodyMat);
        finalScene.add(bodyPoints);

        const facePos = new Float32Array(face.length * 3);
        face.forEach((t, i) => {
          facePos[i*3]   = t.x + 25;
          facePos[i*3+1] = t.y + 40;
          facePos[i*3+2] = t.z;
        });

        const faceGeo = new THREE.BufferGeometry();
        faceGeo.setAttribute("position", new THREE.BufferAttribute(facePos, 3));

        const faceMat = new THREE.PointsMaterial({
          color: new THREE.Color(colorHex), // âœ… ä½¿ç”¨ç•¶å‰é¡è‰²
          size: 1.0,
          transparent: true,
          opacity: 0.85,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const facePoints = new THREE.Points(faceGeo, faceMat);
        finalScene.add(facePoints);

        bodyPoints.scale.set(0.35, 0.35, 0.35);
        facePoints.scale.set(0.35, 0.35, 0.35);

        finalRenderer.render(finalScene, finalCamera);
      });
    }

    function loadFinalCharacterPoints(src) {
      return new Promise(resolve => {
        const img = new Image();
        img.src = src;

        img.onload = () => {
          const c = document.createElement("canvas");
          const ctx = c.getContext("2d");

          const size = 240;
          c.width = size;
          c.height = size;
          ctx.drawImage(img, 0, 0, size, size);

          const data = ctx.getImageData(0, 0, size, size).data;
          finalTargets = [];

          const scale = 220;

          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              const i = (y * size + x) * 4;

              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const alpha = data[i + 3];
              const brightness = (r + g + b) / 3;

              if (alpha < 50) continue;

              const px = (x / size - 0.5) * scale;
              const py = -(y / size - 0.5) * scale;

              if (brightness > 165 && alpha > 60) {
                if (Math.random() > 0.1) {
                  finalTargets.push({
                    x: (x / size - 0.5) * scale,
                    y: -(y / size - 0.5) * scale,
                    z: 3,
                    face: true
                  });
                }

                if (Math.random() > 0.6) {
                  finalTargets.push({
                    x: (x / size - 0.5) * scale + (Math.random() - 0.5) * 2,
                    y: -(y / size - 0.5) * scale + (Math.random() - 0.5) * 2,
                    z: 4,
                    face: true
                  });
                }
              }
              else {
                if (Math.random() < 0.22) {
                  finalTargets.push({ x: px, y: py, z: 0 });
                }
              }
            }
          }

          resolve();
        };
      });
    }

    function startFinalCharacter() {
      stopFinalCharacter();
      finalAnimating = true;

      const loop = () => {
        if (!finalAnimating || !finalRenderer) return;

        finalRenderer.render(finalScene, finalCamera);
        finalRAF = requestAnimationFrame(loop);
      };

      loop();
    }

    function stopFinalCharacter() {
      finalAnimating = false;
      if (finalRAF) {
        cancelAnimationFrame(finalRAF);
        finalRAF = null;
      }
    }

    function switchScreen(state) {
      document.querySelectorAll(".screen").forEach(el=>{
        el.classList.remove("active");
      });

      const target = document.getElementById(state.toLowerCase());
      if (target) target.classList.add("active");
    }

    /* ================= Firebase ç‹€æ…‹ ================= */
    
    let controlProcessing = false; // âœ… é˜²æ­¢é‡è¤‡è§¸ç™¼
    
    // âœ… ç›£è½ control æŒ‡ä»¤(å¾æ‰‹æ©Ÿæ§åˆ¶)
    onValue(ref(db, "control"), async (snapshot) => {
      const control = snapshot.val();
      if (!control || !control.action || controlProcessing) return;

      console.log("æ”¶åˆ°æ§åˆ¶æŒ‡ä»¤:", control);
      controlProcessing = true;

      if (control.action === "START" && control.code) {
        console.log("ğŸš€ é–‹å§‹ START æµç¨‹...");
        
        // 1. å…ˆå¾ GAS è¼‰å…¥è³‡æ–™
        try {
          const res = await fetch(
            "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + control.code
          );
          const data = await res.json();

          if (data && data.id) {
            // å¯«å…¥ session
            await set(ref(db, "session"), {
              id: data.id,
              name: data.name,
              color: data.color,
              title: data.title,
              conclusion: data.conclusion
            });
            console.log("âœ… Session è³‡æ–™å·²è¼‰å…¥:", data);
            
            // âœ… æ›´æ–°å…¨åŸŸé¡è‰²è®Šæ•¸
            colorHex = data.color;
          }
        } catch (err) {
          console.error("âŒ è¼‰å…¥ Session å¤±æ•—:", err);
        }

        // 2. åˆ‡æ›åˆ° LOADING
        await set(ref(db, "runtime/state"), STATES.LOADING);

        // 3. å»¶é²å¾Œé€²å…¥ COSMOS (å¢åŠ å»¶é²æ™‚é–“)
        setTimeout(async () => {
          await set(ref(db, "runtime/state"), STATES.COSMOS);
          // âœ… æ¸…ç©º control,é¿å…é‡è¤‡è§¸ç™¼
          await set(ref(db, "control"), null);
          controlProcessing = false;
          console.log("âœ… é€²å…¥ COSMOS");
        }, 2800); // âœ… å¢åŠ åˆ° 2.8 ç§’
      }

      else if (control.action === "FINAL") {
        await set(ref(db, "runtime/state"), STATES.FINAL);
        controlProcessing = false;
      }

      else if (control.action === "RESET") {
        console.log("ğŸ”„ é–‹å§‹ RESET...");
        
        // âœ… 1. åœæ­¢æ‰€æœ‰å‹•ç•«å’Œè¿½è¹¤
        stopFinalCharacter();
        stopCosmosHandTracking();
        stopCamera();
        
        animating = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        
        // âœ… 2. é‡ç½®æ‰€æœ‰ç‹€æ…‹è®Šæ•¸
        gestureState = "WAITING";
        morphStrength = 0;
        scatterTargets = [];
        gatherPoint = null;
        handData = null;
        
        // âœ… 3. æ¸…ç©ºå ´æ™¯
        if (scene) {
          scene.clear();
          scene = null;
        }
        if (renderer) {
          const cosmosEl = document.getElementById("cosmos");
          const canvas = cosmosEl.querySelector('canvas');
          if (canvas) canvas.remove();
          renderer = null;
        }
        if (finalScene) {
          finalScene.clear();
          finalScene = null;
        }
        if (finalRenderer) {
          const container = document.querySelector(".final-center");
          if (container) container.innerHTML = "";
          finalRenderer = null;
        }
        
        particles = null;
        finalParticles = null;
        
        // âœ… 4. æ¸…ç©º Firebase è³‡æ–™
        await set(ref(db, "session"), null);
        await set(ref(db, "control"), null);
        
        // âœ… 5. å»¶é²åˆ‡æ›åˆ° IDLE (çµ¦æ¸…ç†æ™‚é–“)
        setTimeout(async () => {
          await set(ref(db, "runtime/state"), STATES.IDLE);
          console.log("âœ… RESET å®Œæˆ");
          controlProcessing = false;
        }, 300);
      }
    });

    // âœ… ç›£è½ runtime/state
    onValue(ref(db,"runtime/state"), s=>{
      const state = s.val();
      document.getElementById("debug").textContent = `state: ${state}`;

      if (!state) return;
      switchScreen(state);

      if (state === STATES.IDLE) {
        stopFinalCharacter();
        stopCosmosHandTracking();
        startCamera();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.LOADING) {
        stopFinalCharacter();
        stopCosmosHandTracking();
        stopCamera();
        startLoadingSequence();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.COSMOS) {
        console.log("ğŸŒŒ é€²å…¥ COSMOS ç‹€æ…‹");
        
        stopFinalCharacter();
        stopCamera();
        
        // âœ… å…ˆåœæ­¢èˆŠçš„æ‰‹å‹¢è¿½è¹¤
        stopCosmosHandTracking();
        
        // âœ… æ¸…ç†èˆŠå ´æ™¯
        if (scene) {
          scene.clear();
        }
        if (renderer) {
          const cosmosEl = document.getElementById("cosmos");
          const canvas = cosmosEl.querySelector('canvas');
          if (canvas) canvas.remove();
        }
        
        // âœ… é‡ç½®è®Šæ•¸
        scene = null;
        renderer = null;
        particles = null;
        
        initCosmos();

        animating = true;
        
        // âœ… é‡ç½®ç‹€æ…‹æ©Ÿ
        gestureState = "WAITING";
        
        // âœ… ä¸€é–‹å§‹å°±æ˜¯åˆ†æ•£ç‹€æ…‹
        morphStrength = 0;
        
        // âœ… å…ˆç”¢ç”Ÿåˆ†æ•£ç›®æ¨™
        const w = window.innerWidth * 1.2;
        const h = window.innerHeight * 1.2;
        const d = 800;
        scatterTargets = [];
        for (let i = 0; i < 24000; i++) {
          scatterTargets.push({
            x: (Math.random() - 0.5) * w,
            y: (Math.random() - 0.5) * h,
            z: (Math.random() - 0.5) * d
          });
        }

        // âœ… å»¶é²å•Ÿå‹•æ‰‹å‹¢è¿½è¹¤,ç¢ºä¿ç•«é¢å·²å®Œæˆ
        setTimeout(() => {
          console.log("â° é–‹å§‹å•Ÿå‹•æ‰‹å‹¢è¿½è¹¤ (å»¶é²1ç§’)");
          startCosmosHandTracking();
        }, 1000); // âœ… å¢åŠ åˆ° 1000ms

        if (scene && !rafId) startAnimateLoop();
      }

      else if (state === STATES.FINAL) {
        stopCamera();
        stopCosmosHandTracking();

        animating = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }

        // âœ… æ¸…ç†èˆŠçš„ FINAL å ´æ™¯
        if (finalScene) {
          finalScene.clear();
          finalScene = null;
        }
        if (finalRenderer) {
          const container = document.querySelector(".final-center");
          if (container) container.innerHTML = "";
          finalRenderer = null;
        }

        initFinalCharacter();
        startFinalCharacter();
        startDNA();
        startGrid();
        startHeartbeat();

        // âœ… å¾ Firebase session è®€å–è³‡æ–™
        const sessionRef = ref(db, "session");
        onValue(sessionRef, (snapshot) => {
          const data = snapshot.val();
          
          console.log("ğŸ“Š è®€å– Session è³‡æ–™:", data);
          
          if (data && data.color && data.title && data.conclusion) {
            // âœ… æ›´æ–°å…¨åŸŸé¡è‰²
            colorHex = data.color;
            
            // æ›´æ–°é¡è‰²ç¢¼å’Œåœ“é»
            document.getElementById("final-color-code").textContent = data.color;
            document.getElementById("final-color-dot").style.backgroundColor = data.color;
            
            // æ›´æ–°é …ç›®åç¨±(ç§»é™¤ "GENETIC PROFILE Â· ")
            const itemName = data.title.replace("GENETIC PROFILE Â· ", "").replace("GENETIC PROFILEÂ·", "");
            document.getElementById("final-item").textContent = itemName;
            
            // æ›´æ–°çµè«–æ–‡å­—
            document.getElementById("final-text").textContent = data.conclusion;
          } else {
            document.getElementById("final-color-code").textContent = "#66FFFF";
            document.getElementById("final-color-dot").style.backgroundColor = "#66FFFF";
            document.getElementById("final-item").textContent = "æœªçŸ¥å…ƒç´ ";
            document.getElementById("final-text").textContent = "è«‹å…ˆå¾æ§åˆ¶é¢æ¿è¼‰å…¥è³‡æ–™...";
          }
        }, { onlyOnce: true });
      }
    });

    onValue(ref(db,"session/color"), s=>{
      if(!s.val()) return;
      colorHex=s.val();
      if(particles) particles.material.color.set(colorHex);
      if (finalParticles) finalParticles.material.color.set(colorHex);
    });

    set(ref(db,"runtime/state"),STATES.IDLE);

    addEventListener("keydown", e => {
      if (e.key === "1") set(ref(db,"runtime/state"), STATES.IDLE);
      if (e.key === "2") set(ref(db,"runtime/state"), STATES.LOADING);
      if (e.key === "3") set(ref(db,"runtime/state"), STATES.COSMOS);
      if (e.key === "4") set(ref(db,"runtime/state"), STATES.FINAL);
    });

    window.addEventListener("resize", () => {
      if (camera3D && renderer) {
        camera3D.aspect = window.innerWidth / window.innerHeight;
        camera3D.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    console.log("Three.js ç‰ˆæœ¬:", THREE.REVISION);
    console.log("åˆå§‹ç‹€æ…‹:", STATES.IDLE);

    // âœ… æ¸¬è©¦å‡½æ•¸(å¯åœ¨ Console æ‰‹å‹•å‘¼å«)
    async function testLoadSession(id) {
      const res = await fetch(
        "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + id
      );
      const data = await res.json();

      console.log("GAS data:", data);

      if (data && data.id) {
        await set(ref(db, "session"), {
          id: data.id,
          name: data.name,
          color: data.color,
          title: data.title,
          conclusion: data.conclusion
        });
        console.log("âœ… Session è³‡æ–™å·²å¯«å…¥ Firebase:", data);
        
        // è‡ªå‹•åˆ‡åˆ° FINAL
        await set(ref(db, "runtime/state"), STATES.FINAL);
      }
    }

    window.testLoadSession = testLoadSession;

  </script>
</body>
</html>

