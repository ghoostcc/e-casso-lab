<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>E-casso Lab</title>

  <!-- Three.js（全域） -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
    }

    #idle    { z-index: 1; }
    #loading { z-index: 2; }
    #cosmos  { z-index: 3; }
    #final   { z-index: 4; }

    .screen {
      display: none;
      position: fixed;
      inset: 0;
      align-items: center;
      justify-content: center;
    }

    .screen.active {
      display: flex;
    }

    /* ================= IDLE ================= */
    #idle {
      background-image: url("./bg_idle.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: contain;
      background-color: black;
    }

    #scan-overlay {
      position: absolute;
      left: 30%;
      top: 72%;
      width: 36%;
      height: 18%;
      overflow: hidden;
      pointer-events: none;
    }

    #scan-overlay video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.9;
    }

    .scan-line {
      position: absolute;
      top: -30%;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.7), transparent);
      animation: scanMove 2.5s linear infinite;
    }

    @keyframes scanMove {
      from { top: -30%; }
      to   { top: 100%; }
    }

    /* ================= LOADING ================= */
    .loading-container {
      width: 60%;
      max-width: 800px;
      color: #7ffcff;
      font-family: monospace;
    }

    .progress-bar {
      width: 100%;
      height: 16px;
      border: 1px solid #7ffcff;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, transparent, #7ffcff, transparent);
      transition: width 0.6s ease;
    }

    /* ================= COSMOS ================= */
    #cosmos.active {
      display: block;
      background: black;
    }

    #cosmos canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    #cosmos-hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #7ffcff;
      font-size: 14px;
      color: #7ffcff;
      font-family: monospace;
      display: none;
    }

    #cosmos.active #cosmos-hud {
      display: block;
    }

    .hud-value {
      font-weight: bold;
      color: #7ffcff;
    }

    #cosmos-camera {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 160px;
      height: 120px;
      transform: scaleX(-1);
      opacity: 0.3;
      border: 1px solid #7ffcff;
      z-index: 10;
      display: none;
    }

    #cosmos.active #cosmos-camera {
      display: block;
    }

    #debug {
      position: fixed;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #888;
      z-index: 9999;
    }

    /* ================= FINAL ================= */
    #final {
      background: url("./final_bg.png") center center / contain no-repeat;
      color: #7ffcff;
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    #final.active {
      display: block !important;
    }

    #final {
      align-items: unset !important;
      justify-content: unset !important;
    }

    .final-left {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .bio-slot {
      position: absolute;
      overflow: hidden;
    }

    .bio-slot canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .bio-slot-1 {
      left: 350px;
      top: 250px;
      width: 320px;
      height: 150px;
    }

    .bio-slot-2 {
      left: 350px;
      top: 430px;
      width: 320px;
      height: 200px;
    }

    .bio-slot-3 {
      left: 330px;
      top: 688px;
      width: 260px;
      height: 120px;
    }

    .final-center {
      position: absolute;
      left: 22%;
      top: 0;
      width: 52%;
      height: 100%;
      pointer-events: none;
    }

    .final-right {
      position: absolute !important;
      top: 180px;
      right: 289px;
      width: 380px;
      color: #7ffcff;
      font-family: monospace;
      text-shadow: 0 0 8px rgba(0,255,255,0.25);
    }

    .final-right h2 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 2px;
    }

    .final-right p {
      margin-top: 18px;
      font-size: 14px;
      line-height: 1.7;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>

  <!-- IDLE -->
  <div id="idle" class="screen active">
    <div id="scan-overlay">
      <video id="camera" autoplay muted playsinline></video>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="loading" class="screen">
    <div class="loading-container">
      <div id="loading-text">初始化中…</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div id="progress-percent">0%</div>
    </div>
  </div>

  <!-- COSMOS -->
  <div id="cosmos" class="screen">
    <div id="cosmos-hud">
      <div>手勢: <span id="gesture" class="hud-value">等待中...</span></div>
      <div>手指數: <span id="fingers" class="hud-value">0</span></div>
      <div>模式: <span id="mode" class="hud-value">角色顯示</span></div>
    </div>
    <video id="cosmos-camera" autoplay muted playsinline></video>
  </div>

  <!-- FINAL -->
  <div id="final" class="screen">
    <div class="final-left">
      <div class="bio-slot bio-slot-1"><canvas id="dnaCanvas"></canvas></div>
      <div class="bio-slot bio-slot-2"><canvas id="gridCanvas"></canvas></div>
      <div class="bio-slot bio-slot-3"><canvas id="heartCanvas"></canvas></div>
    </div>
    <div class="final-center"></div>
    <div class="final-right">
      <h2 id="final-title">GENETIC ANALYSIS</h2>
      <p id="final-text">Awaiting biological conclusion...</p>
    </div>
  </div>

  <div id="debug">state: —</div>

  <script type="module">
    const THREE = window.THREE;

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    
    const app = initializeApp({
      apiKey: "AIzaSyAoH3O3t8SYirmcCPVDG19bVC_Nh2VrAQc",
      authDomain: "e-casso-lab.firebaseapp.com",
      databaseURL: "https://e-casso-lab-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "e-casso-lab",
      storageBucket: "e-casso-lab.firebasestorage.app",
      messagingSenderId: "338061345474",
      appId: "1:338061345474:web:60a9b6c2a6d03e131e715b"
    });
    const db = getDatabase(app);

    const STATES = {
      IDLE: "IDLE",
      LOADING: "LOADING",
      COSMOS: "COSMOS",
      FINAL: "FINAL"
    };

    /* ================= FINAL CHARACTER (globals) ================= */
    let finalScene = null;
    let finalCamera = null;
    let finalRenderer = null;
    let finalParticles = null;
    let finalTargets = [];
    let finalRAF = null;
    let finalAnimating = false;

    /* ================= 鏡頭 ================= */
    let camStream = null;
    const video = document.getElementById("camera");

    function startCamera() {
      if (camStream) return;
      navigator.mediaDevices.getUserMedia({ video:true }).then(s=>{
        camStream = s;
        video.srcObject = s;
      }).catch(err=>{
        console.warn("camera error:", err);
      });
    }

    function stopCamera() {
      if (!camStream) return;
      camStream.getTracks().forEach(t=>t.stop());
      camStream = null;
      video.srcObject = null;
    }

    /* ================= 手勢追蹤變數 ================= */
    let cosmosHandStream = null;
    let cosmosHands = null;
    let cosmosCamera = null;
    let handData = null;
    let scatterTargets = [];
    let gatherPoint = null;

    /* ================= COSMOS ================= */
    let scene, camera3D, renderer, particles;
    let animating = false;
    let colorHex = "#66ffff";
    let characterTargets = [];
    let morphStrength = 0;
    let rafId = null;

    /* ================= 手勢偵測函數 ================= */
    function countFingers(landmarks) {
      let count = 0;
      
      if (landmarks[8].y < landmarks[6].y) count++;
      if (landmarks[12].y < landmarks[10].y) count++;
      if (landmarks[16].y < landmarks[14].y) count++;
      if (landmarks[20].y < landmarks[18].y) count++;
      
      const wrist = landmarks[0];
      const indexMCP = landmarks[5];
      const thumbTip = landmarks[4];
      const scale = Math.hypot(indexMCP.x - wrist.x, indexMCP.y - wrist.y);
      const thumbDist = Math.hypot(thumbTip.x - indexMCP.x, thumbTip.y - indexMCP.y);
      
      if (thumbDist > scale * 0.5) count++;
      
      return count;
    }

    function onHandResults(results) {
      handData = null;
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const fingerCount = countFingers(landmarks);
        handData = { landmarks, fingerCount };
        
        document.getElementById('fingers').innerText = fingerCount;
        
        if (fingerCount >= 4) {
          document.getElementById('gesture').innerText = '張開手掌';
          document.getElementById('mode').innerText = '粒子分散';
          setScatterMode();
        } else if (fingerCount <= 1) {
          document.getElementById('gesture').innerText = '握拳';
          document.getElementById('mode').innerText = '聚合到手掌';
          setGatherMode();
        } else {
          document.getElementById('gesture').innerText = '部分張開';
          document.getElementById('mode').innerText = '顯示角色';
          morphStrength = 1;
        }
      } else {
        document.getElementById('gesture').innerText = '未偵測';
        document.getElementById('mode').innerText = '顯示角色';
        morphStrength = 1;
      }
    }

    function setScatterMode() {
      const w = window.innerWidth * 1.2;
      const h = window.innerHeight * 1.2;
      const d = 800;
      
      if (scatterTargets.length === 0) {
        for (let i = 0; i < 24000; i++) {
          scatterTargets.push({
            x: (Math.random() - 0.5) * w,
            y: (Math.random() - 0.5) * h,
            z: (Math.random() - 0.5) * d
          });
        }
      }
      
      morphStrength = 0;
    }

    function setGatherMode() {
      if (!handData || !particles) return;
      
      const vFOV = THREE.MathUtils.degToRad(camera3D.fov);
      const heightAtZ0 = 2 * Math.tan(vFOV / 2) * camera3D.position.z;
      const widthAtZ0 = heightAtZ0 * camera3D.aspect;
      
      const palmCenter = handData.landmarks[9];
      const centerX = -(palmCenter.x - 0.5) * widthAtZ0;
      const centerY = -(palmCenter.y - 0.5) * heightAtZ0;
      
      morphStrength = -1;
      gatherPoint = { x: centerX, y: centerY, z: 0 };
    }

    function startCosmosHandTracking() {
      if (cosmosHands) return;
      
      const videoElement = document.getElementById('cosmos-camera');
      
      if (!videoElement) {
        console.error("❌ cosmos-camera 元素不存在");
        return;
      }
      
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          cosmosHandStream = stream;
          videoElement.srcObject = stream;
        })
        .catch(err => {
          console.warn("COSMOS 手勢攝影機錯誤:", err);
        });
      
      cosmosHands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      
      cosmosHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });
      
      cosmosHands.onResults(onHandResults);
      
      cosmosCamera = new Camera(videoElement, {
        onFrame: async () => {
          await cosmosHands.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });
      
      cosmosCamera.start();
      console.log("✅ COSMOS 手勢追蹤已啟動");
    }

    function stopCosmosHandTracking() {
      if (cosmosHandStream) {
        cosmosHandStream.getTracks().forEach(t => t.stop());
        cosmosHandStream = null;
      }
      if (cosmosCamera) {
        cosmosCamera.stop();
        cosmosCamera = null;
      }
      cosmosHands = null;
      handData = null;
      const videoElement = document.getElementById('cosmos-camera');
      if (videoElement) videoElement.srcObject = null;
      console.log("❌ COSMOS 手勢追蹤已停止");
    }

    /* ================= COSMOS 初始化 ================= */
    function initCosmos() {
      if (scene) return;

      console.log("初始化 COSMOS...");

      scene = new THREE.Scene();
      camera3D = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
      camera3D.position.z = 350;

      renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 1);

      const cosmosEl = document.getElementById("cosmos");
      
      // ✅ 修正：保留 HUD 和攝影機,只插入 canvas
      const existingCanvas = cosmosEl.querySelector('canvas');
      if (existingCanvas) existingCanvas.remove();
      
      cosmosEl.insertBefore(renderer.domElement, cosmosEl.firstChild);

      const count = 24000;
      const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        pos[i*3]=(Math.random()-0.5)*500;
        pos[i*3+1]=(Math.random()-0.5)*500;
        pos[i*3+2]=(Math.random()-0.5)*500;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

      const mat = new THREE.PointsMaterial({
        color:new THREE.Color(colorHex),
        size:1.3,
        transparent:true,
        opacity:0.85,
        blending:THREE.AdditiveBlending
      });

      particles = new THREE.Points(geo,mat);
      scene.add(particles);

      console.log("粒子系統建立完成");

      loadCharacterPoints("./character.png").then(() => {
        console.log("角色點雲準備完成，開始動畫");
        if (animating) startAnimateLoop();
      }).catch(() => {
        console.warn("角色點雲失敗（仍可顯示漂浮粒子）");
        if (animating) startAnimateLoop();
      });
    }

    function loadCharacterPoints(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = src;

        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          const targetSize = 160;
          canvas.width = targetSize;
          canvas.height = targetSize;
          ctx.drawImage(img, 0, 0, targetSize, targetSize);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          characterTargets = [];
          const displayScale = 280;

          for(let y=0; y<canvas.height; y++){
            for(let x=0; x<canvas.width; x++){
              const i=(y*canvas.width+x)*4;
              const r = data[i], g = data[i+1], b = data[i+2], alpha = data[i+3];

              const brightness = (r + g + b) / 3;
              const isFace = brightness > 100;

              if ((isFace && alpha > 5) || (!isFace && alpha > 30)) {
                const baseX = (x / canvas.width - 0.5) * displayScale;
                const baseY = -(y / canvas.height - 0.5) * displayScale;

                characterTargets.push({ x: baseX, y: baseY, z: 0 });

                if (isFace && alpha > 50) {
                  if (Math.random() > 0.2) characterTargets.push({ x: baseX + (Math.random()-0.5)*2.5, y: baseY + (Math.random()-0.5)*2.5, z: (Math.random()-0.5)*12 });
                  if (Math.random() > 0.3) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.0, y: baseY + (Math.random()-0.5)*3.0, z: (Math.random()-0.5)*15 });
                  if (brightness > 150 && Math.random() > 0.4) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.5, y: baseY + (Math.random()-0.5)*3.5, z: (Math.random()-0.5)*18 });
                } else if (!isFace && alpha > 200 && Math.random() > 0.7) {
                  characterTargets.push({ x: baseX + (Math.random()-0.5)*1.5, y: baseY + (Math.random()-0.5)*1.5, z: (Math.random()-0.5)*6 });
                }
              }
            }
          }

          console.log(`從圖片生成 ${characterTargets.length} 個目標點`);
          resolve();
        };

        img.onerror = (e) => {
          console.error("圖片載入失敗:", src, e);
          reject(e);
        };
      });
    }

    function startAnimateLoop() {
      if (rafId) cancelAnimationFrame(rafId);

      const loop = () => {
        if (!animating || !particles) return;

        const p = particles.geometry.attributes.position.array;
        const time = Date.now() * 0.0003;

        if (morphStrength === -1 && gatherPoint) {
          for (let i = 0; i * 3 < p.length; i++) {
            const idx = i * 3;
            const noise = 80;
            
            const tx = gatherPoint.x + (Math.random() - 0.5) * noise;
            const ty = gatherPoint.y + (Math.random() - 0.5) * noise;
            const tz = gatherPoint.z + (Math.random() - 0.5) * noise;
            
            p[idx]     += (tx - p[idx]) * 0.12;
            p[idx + 1] += (ty - p[idx + 1]) * 0.12;
            p[idx + 2] += (tz - p[idx + 2]) * 0.12;
          }
        }
        else if (morphStrength === 0 && scatterTargets.length > 0) {
          for (let i = 0; i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = scatterTargets[i] || scatterTargets[0];
            
            p[idx]     += (t.x - p[idx]) * 0.08;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.08;
            p[idx + 2] += (t.z - p[idx + 2]) * 0.08;
          }
        }
        else if (morphStrength === 1 && characterTargets.length > 0) {
          for (let i = 0; i < characterTargets.length && i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = characterTargets[i];
            const breathe = Math.sin(time + i * 0.01) * 0.3;

            p[idx]     += (t.x - p[idx])     * 0.06;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.06;
            p[idx + 2] += (t.z + breathe - p[idx + 2]) * 0.06;
          }

          for (let i = characterTargets.length; i * 3 < p.length; i++) {
            const idx = i * 3;
            p[idx]     += Math.sin(time + i * 0.1) * 0.04;
            p[idx + 1] += Math.cos(time + i * 0.15) * 0.04;
            p[idx + 2] += Math.sin(time + i * 0.2) * 0.04;
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.002;

        renderer.render(scene, camera3D);
        rafId = requestAnimationFrame(loop);
      };

      rafId = requestAnimationFrame(loop);
    }

    /* ================= FINAL 動畫 ================= */
    function startDNA(){
      const c = document.getElementById("dnaCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      let t = 0;
      function loop(){
        ctx.clearRect(0,0,c.width,c.height);
        ctx.strokeStyle = "#7ffcff";
        ctx.lineWidth = 1;

        for(let y=0; y<c.height; y+=3){
          const wave = Math.sin(y*0.05 + t) * 30;
          ctx.beginPath();
          ctx.moveTo(c.width/2 + wave, y);
          ctx.lineTo(c.width/2 - wave, y);
          ctx.stroke();
        }

        t += 0.03;
        requestAnimationFrame(loop);
      }
      loop();
    }

    function startGrid(){
      const c = document.getElementById("gridCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      const dots = Array.from({length:100},()=>({
        x: Math.random()*c.width,
        y: Math.random()*c.height,
        a: Math.random()
      }));

      function loop(){
        ctx.clearRect(0,0,c.width,c.height);

        ctx.strokeStyle = "rgba(127,252,255,0.15)";
        for(let x=0;x<c.width;x+=20){
          ctx.beginPath();
          ctx.moveTo(x,0);
          ctx.lineTo(x,c.height);
          ctx.stroke();
        }
        for(let y=0;y<c.height;y+=20){
          ctx.beginPath();
          ctx.moveTo(0,y);
          ctx.lineTo(c.width,y);
          ctx.stroke();
        }

        dots.forEach(d=>{
          d.a += (Math.random()-0.5)*0.1;
          d.a = Math.max(0,Math.min(1,d.a));
          ctx.fillStyle = `rgba(127,252,255,${d.a})`;
          ctx.fillRect(d.x,d.y,2,2);
        });

        requestAnimationFrame(loop);
      }
      loop();
    }

    function startHeartbeat(){
      const c = document.getElementById("heartCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      let t = 0;
      function loop(){
        ctx.clearRect(0,0,c.width,c.height);
        ctx.strokeStyle = "#7ffcff";
        ctx.lineWidth = 2;
        ctx.beginPath();

        for(let x=0;x<c.width;x++){
          let y =
            c.height/2 +
            Math.sin((x+t)*0.05)*8 +
            (x%120<10 ? -25 : 0);

          ctx.lineTo(x,y);
        }

        ctx.stroke();
        t += 4;
        requestAnimationFrame(loop);
      }
      loop();
    }

    /* ================= LOADING ================= */
    function startLoadingSequence() {
      const steps=[
        {t:"初始化中…",p:10},
        {t:"姓名核對中",p:40},
        {t:"資料確認中",p:75},
        {t:"準備完成",p:100}
      ];
      let i=0;
      const txt=document.getElementById("loading-text");
      const fill=document.getElementById("progress-fill");
      const per=document.getElementById("progress-percent");

      fill.style.width="0%";
      per.textContent="0%";

      function next(){
        if(i>=steps.length)return;
        txt.textContent=steps[i].t;
        fill.style.width=steps[i].p+"%";
        per.textContent=steps[i].p+"%";
        i++;
        setTimeout(next,600);
      }
      setTimeout(next,150);
    }

    /* ================= FINAL 角色 ================= */
    function initFinalCharacter() {
      if (finalScene) return;

      finalScene = new THREE.Scene();
      finalCamera = new THREE.PerspectiveCamera(50, 1, 1, 1000);
      finalCamera.position.z = 180;

      finalRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      finalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const container = document.querySelector(".final-center");
      const w = container.clientWidth;
      const h = container.clientHeight;

      finalRenderer.setSize(w, h);
      finalCamera.aspect = w / h;
      finalCamera.updateProjectionMatrix();

      container.innerHTML = "";
      container.appendChild(finalRenderer.domElement);

      loadFinalCharacterPoints("./character.png").then(() => {
        const body = [];
        const face = [];

        finalTargets.forEach(t => {
          if (t.face) face.push(t);
          else body.push(t);
        });

        const bodyPos = new Float32Array(body.length * 3);
        body.forEach((t, i) => {
          bodyPos[i*3]   = t.x + 25;
          bodyPos[i*3+1] = t.y + 40;
          bodyPos[i*3+2] = t.z;
        });

        const bodyGeo = new THREE.BufferGeometry();
        bodyGeo.setAttribute("position", new THREE.BufferAttribute(bodyPos, 3));

        const bodyMat = new THREE.PointsMaterial({
          color: new THREE.Color(colorHex),
          size: 0.7,
          transparent: true,
          opacity: 0.55,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const bodyPoints = new THREE.Points(bodyGeo, bodyMat);
        finalScene.add(bodyPoints);

        const facePos = new Float32Array(face.length * 3);
        face.forEach((t, i) => {
          facePos[i*3]   = t.x + 25;
          facePos[i*3+1] = t.y + 40;
          facePos[i*3+2] = t.z;
        });

        const faceGeo = new THREE.BufferGeometry();
        faceGeo.setAttribute("position", new THREE.BufferAttribute(facePos, 3));

        const faceMat = new THREE.PointsMaterial({
          color: new THREE.Color(colorHex),
          size: 1.0,
          transparent: true,
          opacity: 0.85,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const facePoints = new THREE.Points(faceGeo, faceMat);
        finalScene.add(facePoints);

        bodyPoints.scale.set(0.35, 0.35, 0.35);
        facePoints.scale.set(0.35, 0.35, 0.35);

        finalRenderer.render(finalScene, finalCamera);
      });
    }

    function loadFinalCharacterPoints(src) {
      return new Promise(resolve => {
        const img = new Image();
        img.src = src;

        img.onload = () => {
          const c = document.createElement("canvas");
          const ctx = c.getContext("2d");

          const size = 240;
          c.width = size;
          c.height = size;
          ctx.drawImage(img, 0, 0, size, size);

          const data = ctx.getImageData(0, 0, size, size).data;
          finalTargets = [];

          const scale = 220;

          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              const i = (y * size + x) * 4;

              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const alpha = data[i + 3];
              const brightness = (r + g + b) / 3;

              if (alpha < 50) continue;

              const px = (x / size - 0.5) * scale;
              const py = -(y / size - 0.5) * scale;

              if (brightness > 165 && alpha > 60) {
                if (Math.random() > 0.1) {
                  finalTargets.push({
                    x: (x / size - 0.5) * scale,
                    y: -(y / size - 0.5) * scale,
                    z: 3,
                    face: true
                  });
                }

                if (Math.random() > 0.6) {
                  finalTargets.push({
                    x: (x / size - 0.5) * scale + (Math.random() - 0.5) * 2,
                    y: -(y / size - 0.5) * scale + (Math.random() - 0.5) * 2,
                    z: 4,
                    face: true
                  });
                }
              }
              else {
                if (Math.random() < 0.22) {
                  finalTargets.push({ x: px, y: py, z: 0 });
                }
              }
            }
          }

          resolve();
        };
      });
    }

    function startFinalCharacter() {
      stopFinalCharacter();
      finalAnimating = true;

      const loop = () => {
        if (!finalAnimating || !finalRenderer) return;

        finalRenderer.render(finalScene, finalCamera);
        finalRAF = requestAnimationFrame(loop);
      };

      loop();
    }

    function stopFinalCharacter() {
      finalAnimating = false;
      if (finalRAF) {
        cancelAnimationFrame(finalRAF);
        finalRAF = null;
      }
    }

    function switchScreen(state) {
      document.querySelectorAll(".screen").forEach(el=>{
        el.classList.remove("active");
      });

      const target = document.getElementById(state.toLowerCase());
      if (target) target.classList.add("active");
    }

    /* ================= Firebase 狀態 ================= */
    onValue(ref(db,"runtime/state"), s=>{
      const state = s.val();
      document.getElementById("debug").textContent = `state: ${state}`;

      if (!state) return;
      switchScreen(state);

      if (state === STATES.IDLE) {
        stopFinalCharacter();
        stopCosmosHandTracking();
        startCamera();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.LOADING) {
        stopFinalCharacter();
        stopCosmosHandTracking();
        stopCamera();
        startLoadingSequence();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.COSMOS) {
        stopFinalCharacter();
        stopCamera();
        initCosmos();

        animating = true;
        morphStrength = 0;

        startCosmosHandTracking();

        setTimeout(() => {
          morphStrength = 1;
        }, 1000);

        if (scene && !rafId) startAnimateLoop();
      }

      else if (state === STATES.FINAL) {
        stopCamera();
        stopCosmosHandTracking();

        animating = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }

        // ✅ 修正：只呼叫一次
        initFinalCharacter();
        startFinalCharacter();
        startDNA();
        startGrid();
        startHeartbeat();

        document.getElementById("final-title").textContent = "GENETIC PROFILE · A01";
        document.getElementById("final-text").textContent =
          "Your biological resonance indicates high adaptability and strong cosmic synchronization.\nFurther evolution recommended.";
      }
    });

    onValue(ref(db,"session/color"), s=>{
      if(!s.val()) return;
      colorHex=s.val();
      if(particles) particles.material.color.set(colorHex);
      if (finalParticles) finalParticles.material.color.set(colorHex);
    });

    set(ref(db,"runtime/state"),STATES.IDLE);

    addEventListener("keydown", e => {
      if (e.key === "1") set(ref(db,"runtime/state"), STATES.IDLE);
      if (e.key === "2") set(ref(db,"runtime/state"), STATES.LOADING);
      if (e.key === "3") set(ref(db,"runtime/state"), STATES.COSMOS);
      if (e.key === "4") set(ref(db,"runtime/state"), STATES.FINAL);
    });

    window.addEventListener("resize", () => {
      if (camera3D && renderer) {
        camera3D.aspect = window.innerWidth / window.innerHeight;
        camera3D.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    console.log("Three.js 版本:", THREE.REVISION);
    console.log("初始狀態:", STATES.IDLE);

    async function testLoadSession(id) {
      const res = await fetch(
        "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + id
      );
      const data = await res.json();

      console.log("GAS data:", data);

      if (data && data.id) {
        await set(ref(db, "session"), data);
        console.log("session written:", data);
      }
    }

    window.testLoadSession = testLoadSession;

  </script>
</body>
</html>
