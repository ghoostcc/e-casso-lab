<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>E-casso Lab</title>

  <!-- Three.jsï¼ˆå…¨åŸŸï¼‰ -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

    <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>


  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
    }

    /* âœ… ç–Šå±¤ï¼šç¢ºä¿ç•«é¢åˆ‡æ›ä¸æœƒäº’ç›¸è“‹ä½ */
    #idle    { z-index: 1; }
    #loading { z-index: 2; }
    #cosmos  { z-index: 3; }  /* COSMOS */
    #final   { z-index: 4; }  /* âœ… FINAL è¦åœ¨æœ€ä¸Š */

    .screen {
      display: none;
      position: fixed;
      inset: 0;

      /* âœ… å…¶ä»–ç•«é¢é è¨­ç½®ä¸­ï¼ˆFINAL æœƒè‡ªå·±è¦†è“‹ï¼‰ */
      align-items: center;
      justify-content: center;
    }

    .screen.active {
      display: flex;
    }

    /* ================= IDLE ================= */
    #idle {
      background-image: url("./bg_idle.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: contain;
      background-color: black;
    }

    #scan-overlay {
      position: absolute;
      left: 30%;
      top: 72%;
      width: 36%;
      height: 18%;
      overflow: hidden;
      pointer-events: none;
    }

    #scan-overlay video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.9;
    }

    .scan-line {
      position: absolute;
      top: -30%;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(
        to bottom,
        transparent,
        rgba(255,255,255,0.7),
        transparent
      );
      animation: scanMove 2.5s linear infinite;
    }

    @keyframes scanMove {
      from { top: -30%; }
      to   { top: 100%; }
    }

    /* ================= LOADING ================= */
    .loading-container {
      width: 60%;
      max-width: 800px;
      color: #7ffcff;
      font-family: monospace;
    }

    .progress-bar {
      width: 100%;
      height: 16px;
      border: 1px solid #7ffcff;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(
        90deg,
        transparent,
        #7ffcff,
        transparent
      );
      transition: width 0.6s ease;
    }

    /* âœ… COSMOSï¼šè®“ canvas å……æ»¿æ•´å€‹ç•«é¢ */
    #cosmos.active {
      display: block;
      background: black;
    }
    #cosmos canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    #debug {
      position: fixed;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #888;
      z-index: 9999;
    }

    /* ================= FINAL ================= */
    #final{
      /* âœ… èƒŒæ™¯ HUD */
      background: url("./final_bg.png") center center / contain no-repeat;
      color: #7ffcff;

      /* âœ… è®“ absolute å­å…ƒç´ ä»¥ FINAL ç‚ºåŸºæº– */
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    /* âœ… æ–·æ ¹ï¼šFINAL ä¸èƒ½è¢« .screen.active çš„ flex å½±éŸ¿ */
    #final.active{
      display: block !important;
    }

    /* âœ… è®“ FINAL ä¸åƒ screen çš„ç½®ä¸­å±¬æ€§ */
    #final{
      align-items: unset !important;
      justify-content: unset !important;
    }

/* å·¦å´ BIO å€ï¼ˆé€™å€‹å®¹å™¨åªç•¶å®šä½åƒè€ƒï¼Œä¸è¦å†ç”¨ flexï¼‰ */
.final-left{
  position: absolute;
  inset: 0;              /* è®“å®ƒè·Ÿ final ä¸€æ¨£å¤§ï¼Œæ–¹ä¾¿ç”¨ top/left å°é½Š */
  pointer-events: none;
}

/* ä¸‰å€‹æ´ï¼šå…±åŒè¨­å®š */
.bio-slot{
  position: absolute;
  overflow: hidden;      /* ä¿è­‰å‹•ç•«ä¸æœƒæº¢å‡ºæ¡†å¤– */
}

/* Canvas å¡«æ»¿æ´ */
.bio-slot canvas{
  width: 100%;
  height: 100%;
  display: block;
}

/* ========= ä¸‰å€‹æ´çš„ä½ç½®ï¼ˆä½ åªè¦èª¿é€™è£¡ï¼‰ ========= */
/* ä¸Šæ¡†ï¼šDNA */
.bio-slot-1{
  left: 350px;     /* âœ… å·¦å³ä½ç½®å¾®èª¿ */
  top: 250px;     /* âœ… ä¸Šä¸‹ä½ç½®å¾®èª¿ */
  width: 320px;   /* âœ… å¯¬åº¦å¾®èª¿ */
  height: 150px;  /* âœ… é«˜åº¦å¾®èª¿ */
}

/* ä¸­æ¡†ï¼šGrid */
.bio-slot-2{
  left: 350px;
  top: 430px;
  width: 320px;
  height: 200px;
}

/* ä¸‹æ¡†ï¼šHeartbeat */
.bio-slot-3{
  left: 330px;
  top: 688px;
  width: 260px;
  height: 120px;
}

    /* ä¸­å¤®ä¿ç•™çµ¦ COSMOSï¼ˆä¸ç”¨æ”¾å…§å®¹ï¼‰ */
    /* FINAL ä¸­å¤®è§’è‰²ï¼ˆCanvas ç²’å­ï¼‰ */
.final-center {
  position: absolute;
  left: 22%;
  top: 0;
  width: 52%;
  height: 100%;
  pointer-events: none;
}

#finalCharacter {
  position: absolute;
  left: 50%;
  top: 52%;
  transform: translate(-50%, -50%);
  width: 320px;
  height: 420px;
}


    /* âœ… å³å´ Conclusionï¼šè²¼é€²å³å´æ¡† */
    .final-right{
      position: absolute !important;
      top: 180px;
      right: 289px;
      width: 380px;

      color: #7ffcff;
      font-family: monospace;
      text-shadow: 0 0 8px rgba(0,255,255,0.25);
    }

    .final-right h2{
      margin: 0;
      font-size: 20px;
      letter-spacing: 2px;
    }

    .final-right p{
      margin-top: 18px;
      font-size: 14px;
      line-height: 1.7;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>

  <!-- IDLE -->
  <div id="idle" class="screen active">
    <div id="scan-overlay">
      <video id="camera" autoplay muted playsinline></video>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="loading" class="screen">
    <div class="loading-container">
      <div id="loading-text">åˆå§‹åŒ–ä¸­â€¦</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div id="progress-percent">0%</div>
    </div>
  </div>

  <!-- COSMOS -->
  <div id="cosmos" class="screen"></div>

<!-- FINAL -->
<div id="final" class="screen">

  <!-- å·¦å´ BIO ä¸‰æ ¼å‹•ç•« -->
  <div class="final-left">
  <div class="bio-slot bio-slot-1"><canvas id="dnaCanvas"></canvas></div>
  <div class="bio-slot bio-slot-2"><canvas id="gridCanvas"></canvas></div>
  <div class="bio-slot bio-slot-3"><canvas id="heartCanvas"></canvas></div>
</div>


  <!-- ä¸­å¤®ï¼ˆCOSMOS ç”¨ï¼‰ -->
  <div class="final-center">
</div>


  <!-- å³å´ Conclusion -->
  <div class="final-right">
    <h2 id="final-title">GENETIC ANALYSIS</h2>
    <p id="final-text">Awaiting biological conclusion...</p>
  </div>

</div>


  <div id="debug">state: â€”</div>

  <script type="module">
    const THREE = window.THREE;

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    
    const app = initializeApp({
      apiKey: "AIzaSyAoH3O3t8SYirmcCPVDG19bVC_Nh2VrAQc",
      authDomain: "e-casso-lab.firebaseapp.com",
      databaseURL: "https://e-casso-lab-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "e-casso-lab",
      storageBucket: "e-casso-lab.firebasestorage.app",
      messagingSenderId: "338061345474",
      appId: "1:338061345474:web:60a9b6c2a6d03e131e715b"
    });
    const db = getDatabase(app);

    const STATES = {
      IDLE: "IDLE",
      LOADING: "LOADING",
      COSMOS: "COSMOS",
      FINAL: "FINAL"
    };

    /* ================= FINAL CHARACTER (globals) ================= */
let finalScene = null;
let finalCamera = null;
let finalRenderer = null;
let finalParticles = null;
let finalTargets = [];

let finalRAF = null;
let finalAnimating = false;

    /* ================= é¡é ­ ================= */
    let camStream = null;
    const video = document.getElementById("camera");

    function startCamera() {
      if (camStream) return;
      navigator.mediaDevices.getUserMedia({ video:true }).then(s=>{
        camStream = s;
        video.srcObject = s;
      }).catch(err=>{
        console.warn("camera error:", err);
      });
    }
    function stopCamera() {
      if (!camStream) return;
      camStream.getTracks().forEach(t=>t.stop());
      camStream = null;
      video.srcObject = null;
    }

    /* ================= COSMOS ================= */
    let scene, camera3D, renderer, particles;
    let animating = false;
    let colorHex = "#66ffff";
    let characterTargets = [];
    let morphStrength = 0;
    let rafId = null;

    function initCosmos() {
      if (scene) return;

      console.log("åˆå§‹åŒ– COSMOS...");

      scene = new THREE.Scene();
      camera3D = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
      camera3D.position.z = 350;

      renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 1);

      const cosmosEl = document.getElementById("cosmos");
      cosmosEl.innerHTML = "";
      cosmosEl.appendChild(renderer.domElement);

      renderer.render(scene, camera3D);

      const count = 24000;
      const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        pos[i*3]=(Math.random()-0.5)*500;
        pos[i*3+1]=(Math.random()-0.5)*500;
        pos[i*3+2]=(Math.random()-0.5)*500;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

      const mat = new THREE.PointsMaterial({
        color:new THREE.Color(colorHex),
        size:1.3,
        transparent:true,
        opacity:0.85,
        blending:THREE.AdditiveBlending
      });

      particles = new THREE.Points(geo,mat);
      scene.add(particles);

      console.log("ç²’å­ç³»çµ±å»ºç«‹å®Œæˆ");

      loadCharacterPoints("./character.png").then(() => {
        console.log("è§’è‰²é»é›²æº–å‚™å®Œæˆï¼Œé–‹å§‹å‹•ç•«");
        if (animating) startAnimateLoop();
      }).catch(() => {
        console.warn("è§’è‰²é»é›²å¤±æ•—ï¼ˆä»å¯é¡¯ç¤ºæ¼‚æµ®ç²’å­ï¼‰");
        if (animating) startAnimateLoop();
      });
    }

    function loadCharacterPoints(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = src;

        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          const targetSize = 160;
          canvas.width = targetSize;
          canvas.height = targetSize;
          ctx.drawImage(img, 0, 0, targetSize, targetSize);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          characterTargets = [];
          const displayScale = 280;

          for(let y=0; y<canvas.height; y++){
            for(let x=0; x<canvas.width; x++){
              const i=(y*canvas.width+x)*4;
              const r = data[i], g = data[i+1], b = data[i+2], alpha = data[i+3];

              const brightness = (r + g + b) / 3;
              const isFace = brightness > 100;

              if ((isFace && alpha > 5) || (!isFace && alpha > 30)) {
                const baseX = (x / canvas.width - 0.5) * displayScale;
                const baseY = -(y / canvas.height - 0.5) * displayScale;

                characterTargets.push({ x: baseX, y: baseY, z: 0 });

                if (isFace && alpha > 50) {
                  if (Math.random() > 0.2) characterTargets.push({ x: baseX + (Math.random()-0.5)*2.5, y: baseY + (Math.random()-0.5)*2.5, z: (Math.random()-0.5)*12 });
                  if (Math.random() > 0.3) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.0, y: baseY + (Math.random()-0.5)*3.0, z: (Math.random()-0.5)*15 });
                  if (brightness > 150 && Math.random() > 0.4) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.5, y: baseY + (Math.random()-0.5)*3.5, z: (Math.random()-0.5)*18 });
                } else if (!isFace && alpha > 200 && Math.random() > 0.7) {
                  characterTargets.push({ x: baseX + (Math.random()-0.5)*1.5, y: baseY + (Math.random()-0.5)*1.5, z: (Math.random()-0.5)*6 });
                }
              }
            }
          }

          console.log(`å¾åœ–ç‰‡ç”Ÿæˆ ${characterTargets.length} å€‹ç›®æ¨™é»`);
          resolve();
        };

        img.onerror = (e) => {
          console.error("åœ–ç‰‡è¼‰å…¥å¤±æ•—:", src, e);
          reject(e);
        };
      });
    }

    function startAnimateLoop() {
      if (rafId) cancelAnimationFrame(rafId);

      const loop = () => {
        console.log("morphStrength:", morphStrength);
        if (!animating || !particles) return;

        const p = particles.geometry.attributes.position.array;
        const time = Date.now() * 0.0003;

        const hasTargets = characterTargets.length > 0;

        if (hasTargets) {
          for (let i = 0; i < characterTargets.length && i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = characterTargets[i];
            const breathe = Math.sin(time + i * 0.01) * 0.3;

            p[idx]     += (t.x - p[idx])     * 0.06 * morphStrength;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.06 * morphStrength;
            p[idx + 2] += (t.z + breathe - p[idx + 2]) * 0.06 * morphStrength;
          }
        }

        for (let i = hasTargets ? characterTargets.length : 0; i * 3 < p.length; i++) {
          const idx = i * 3;
          p[idx]     += Math.sin(time + i * 0.1) * 0.04 * (1 - morphStrength);
          p[idx + 1] += Math.cos(time + i * 0.15) * 0.04 * (1 - morphStrength);
          p[idx + 2] += Math.sin(time + i * 0.2) * 0.04 * (1 - morphStrength);
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.002;

        renderer.render(scene, camera3D);
        rafId = requestAnimationFrame(loop);
      };

      rafId = requestAnimationFrame(loop);
    }

    function startDNA(){
  const c = document.getElementById("dnaCanvas");
  if (!c) return;
  const ctx = c.getContext("2d");

  function resize(){
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let t = 0;
  function loop(){
    ctx.clearRect(0,0,c.width,c.height);
    ctx.strokeStyle = "#7ffcff";
    ctx.lineWidth = 1;

    for(let y=0; y<c.height; y+=3){
      const wave = Math.sin(y*0.05 + t) * 30;
      ctx.beginPath();
      ctx.moveTo(c.width/2 + wave, y);
      ctx.lineTo(c.width/2 - wave, y);
      ctx.stroke();
    }

    t += 0.03;
    requestAnimationFrame(loop);
  }
  loop();
}

function startGrid(){
  const c = document.getElementById("gridCanvas");
  if (!c) return;
  const ctx = c.getContext("2d");

  function resize(){
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const dots = Array.from({length:100},()=>({
    x: Math.random()*c.width,
    y: Math.random()*c.height,
    a: Math.random()
  }));

  function loop(){
    ctx.clearRect(0,0,c.width,c.height);

    ctx.strokeStyle = "rgba(127,252,255,0.15)";
    for(let x=0;x<c.width;x+=20){
      ctx.beginPath();
      ctx.moveTo(x,0);
      ctx.lineTo(x,c.height);
      ctx.stroke();
    }
    for(let y=0;y<c.height;y+=20){
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(c.width,y);
      ctx.stroke();
    }

    dots.forEach(d=>{
      d.a += (Math.random()-0.5)*0.1;
      d.a = Math.max(0,Math.min(1,d.a));
      ctx.fillStyle = `rgba(127,252,255,${d.a})`;
      ctx.fillRect(d.x,d.y,2,2);
    });

    requestAnimationFrame(loop);
  }
  loop();
}

function startHeartbeat(){
  const c = document.getElementById("heartCanvas");
  if (!c) return;
  const ctx = c.getContext("2d");

  function resize(){
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let t = 0;
  function loop(){
    ctx.clearRect(0,0,c.width,c.height);
    ctx.strokeStyle = "#7ffcff";
    ctx.lineWidth = 2;
    ctx.beginPath();

    for(let x=0;x<c.width;x++){
      let y =
        c.height/2 +
        Math.sin((x+t)*0.05)*8 +
        (x%120<10 ? -25 : 0);

      ctx.lineTo(x,y);
    }

    ctx.stroke();
    t += 4;
    requestAnimationFrame(loop);
  }
  loop();
}

    /* ================= LOADING ================= */
    function startLoadingSequence() {
      const steps=[
        {t:"åˆå§‹åŒ–ä¸­â€¦",p:10},
        {t:"å§“åæ ¸å°ä¸­",p:40},
        {t:"è³‡æ–™ç¢ºèªä¸­",p:75},
        {t:"æº–å‚™å®Œæˆ",p:100}
      ];
      let i=0;
      const txt=document.getElementById("loading-text");
      const fill=document.getElementById("progress-fill");
      const per=document.getElementById("progress-percent");

      fill.style.width="0%";
      per.textContent="0%";

      function next(){
        if(i>=steps.length)return;
        txt.textContent=steps[i].t;
        fill.style.width=steps[i].p+"%";
        per.textContent=steps[i].p+"%";
        i++;
        setTimeout(next,600);
      }
      setTimeout(next,150);
    }

// ================= FINAL ä¸­å¤®è§’è‰²ï¼ˆä¸€æ¬¡æˆå‹ï¼Œä¸ç™¼æ•£ï¼‰ =================
function initFinalCharacter() {
  if (finalScene) return;

  // --- Scene ---
  finalScene = new THREE.Scene();

  // --- Cameraï¼ˆFINAL å°ˆç”¨ï¼Œè¼ƒè¿‘ã€ä¸åƒæ•´å€‹ç•«é¢ï¼‰ ---
  finalCamera = new THREE.PerspectiveCamera(
    50,
    1,        // å…ˆçµ¦ 1ï¼Œä¸‹é¢æœƒç”¨ container é‡ç®—
    1,
    1000
  );
  finalCamera.position.z = 180; // â† æ§åˆ¶è§’è‰²é è¿‘ï¼ˆ150~220ï¼‰

  // --- Renderer ---
  finalRenderer = new THREE.WebGLRenderer({
    alpha: true,
    antialias: true
  });
  finalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // âœ… åªåƒ FINAL ä¸­å¤®æ¡†
  const container = document.querySelector(".final-center");
  const w = container.clientWidth;
  const h = container.clientHeight;

  finalRenderer.setSize(w, h);
  finalCamera.aspect = w / h;
  finalCamera.updateProjectionMatrix();

  container.innerHTML = "";
  container.appendChild(finalRenderer.domElement);

  // --- è¼‰å…¥è§’è‰²é»é›²ï¼ˆä¸€é–‹å§‹å°±æˆäººå‹ï¼‰ ---
loadFinalCharacterPoints("./character.png").then(() => {

  // â‘  åˆ†é¡ï¼šèº«é«” / è‡‰
  const body = [];
  const face = [];

  finalTargets.forEach(t => {
    if (t.face) face.push(t);
    else body.push(t);
  });

  /* ================= èº«é«” ================= */

  const bodyPos = new Float32Array(body.length * 3);
  body.forEach((t, i) => {
    bodyPos[i*3]   = t.x + 25;
    bodyPos[i*3+1] = t.y + 40;
    bodyPos[i*3+2] = t.z;
  });

  const bodyGeo = new THREE.BufferGeometry();
  bodyGeo.setAttribute("position", new THREE.BufferAttribute(bodyPos, 3));

  const bodyMat = new THREE.PointsMaterial({
    color: new THREE.Color("#ffffff"),
    size: 0.7,
    transparent: true,
    opacity: 0.55,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const bodyPoints = new THREE.Points(bodyGeo, bodyMat);
  finalScene.add(bodyPoints);

  /* ================= è‡‰ ================= */

  const facePos = new Float32Array(face.length * 3);
  face.forEach((t, i) => {
    facePos[i*3]   = t.x + 25;
    facePos[i*3+1] = t.y + 40;
    facePos[i*3+2] = t.z; // z å·²ç¶“åœ¨ç”¢ç”Ÿæ™‚å¾€å‰
  });

  const faceGeo = new THREE.BufferGeometry();
  faceGeo.setAttribute("position", new THREE.BufferAttribute(facePos, 3));

  const faceMat = new THREE.PointsMaterial({
    color: new THREE.Color("#ffffff"),
    size: 1.0,          // âœ… è‡‰æ¯”è¼ƒå¤§
    transparent: true,
    opacity: 0.85,      // âœ… è‡‰æ¯”è¼ƒäº®
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const facePoints = new THREE.Points(faceGeo, faceMat);
  finalScene.add(facePoints);

  finalParticles = { body: bodyPoints, face: facePoints };

  // âœ… é—œéµï¼šæŠŠ FINAL ç²’å­å­˜èµ·ä¾†ï¼Œè®“å¤–éƒ¨å¯ä»¥æ”¹é¡è‰²
finalParticles = {
  body: bodyPoints,
  face: facePoints
};

  // æ•´é«”å¤§å°ï¼ˆå…©å±¤ä¸€èµ·ï¼‰
  bodyPoints.scale.set(0.35, 0.35, 0.35);
  facePoints.scale.set(0.35, 0.35, 0.35);

  finalRenderer.render(finalScene, finalCamera);
});
}


// ================= å¾åœ–ç‰‡ç”Ÿæˆ FINAL è§’è‰²é»ï¼ˆä¿®æ­£ç‰ˆï¼‰ =================
function loadFinalCharacterPoints(src) {
  return new Promise(resolve => {
    const img = new Image();
    img.src = src;

    img.onload = () => {
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");

      const size = 240;
      c.width = size;
      c.height = size;
      ctx.drawImage(img, 0, 0, size, size);

      const data = ctx.getImageData(0, 0, size, size).data;
      finalTargets = [];

      const scale = 220;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const i = (y * size + x) * 4;

          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const alpha = data[i + 3];
          const brightness = (r + g + b) / 3;

          if (alpha < 50) continue;

          const px = (x / size - 0.5) * scale;
          const py = -(y / size - 0.5) * scale;

// ğŸ‘¤ è‡‰éƒ¨å¼·åŒ–ï¼ˆæ¨™è¨˜ç‚º faceï¼‰
if (brightness > 165 && alpha > 60) {

  // æ ¸å¿ƒè‡‰
  if (Math.random() > 0.1) {
    finalTargets.push({
      x: (x / size - 0.5) * scale,
      y: -(y / size - 0.5) * scale,
      z: 3,              // âœ… è‡‰æ›´å‰
      face: true         // âœ… é—œéµæ¨™è¨˜
    });
  }

  // è¼ªå»“è£œé»
  if (Math.random() > 0.6) {
    finalTargets.push({
      x: (x / size - 0.5) * scale + (Math.random() - 0.5) * 2,
      y: -(y / size - 0.5) * scale + (Math.random() - 0.5) * 2,
      z: 4,
      face: true
    });
  }
}


          // ğŸ§ èº«é«”ï¼ˆæš—è‰²ï¼‰â€” ä¸€å®šè¦æŠ½
          else {
            if (Math.random() < 0.22) {
              finalTargets.push({ x: px, y: py, z: 0 });
            }
          }
        }
      }

      resolve();
    };
  });
}



// FINAL å‹•ç•«ï¼ˆåªåšå¾®å‘¼å¸ï¼‰
function startFinalCharacter() {
  stopFinalCharacter();
  finalAnimating = true;

  const loop = () => {
    if (!finalAnimating || !finalParticles) return;

    const p = finalParticles.geometry.attributes.position.array;
    const t = Date.now() * 0.001;

    for (let i = 0; i * 3 < p.length; i++) {
      p[i * 3 + 2] += Math.sin(t + i * 0.02) * 0.03;
    }

    finalParticles.geometry.attributes.position.needsUpdate = true;
    finalRenderer.render(finalScene, finalCamera);
    finalRAF = requestAnimationFrame(loop);
  };

  loop();
}

// FINAL åœæ­¢ï¼ˆé›¢é–‹æ™‚ä¸€å®šè¦ï¼‰
function stopFinalCharacter() {
  finalAnimating = false;
  if (finalRAF) {
    cancelAnimationFrame(finalRAF);
    finalRAF = null;
  }
}


    function switchScreen(state) {
      document.querySelectorAll(".screen").forEach(el=>{
        el.classList.remove("active");
      });

      const target = document.getElementById(state.toLowerCase());
      if (target) target.classList.add("active");
    }

    /* ================= Firebase ç‹€æ…‹ ================= */
    onValue(ref(db,"runtime/state"), s=>{
      const state = s.val();
      document.getElementById("debug").textContent = `state: ${state}`;

      if (!state) return;
      switchScreen(state);

      if (state === STATES.IDLE) {
        stopFinalCharacter();
        startCamera();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.LOADING) {
        stopFinalCharacter();
        stopCamera();
        startLoadingSequence();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

     else if (state === STATES.COSMOS) {
  stopFinalCharacter();

  // âœ… çµ¦ MediaPipe ç”¨
  startCamera();

  // âœ… å•Ÿå‹•æ‰‹å‹¢åµæ¸¬ï¼ˆé—œéµï¼‰
  initHands(video);

  initCosmos();

  animating = true;
  morphStrength = 0;

  if (scene && !rafId) startAnimateLoop();
}

      else if (state === STATES.FINAL) {
  stopCamera();
  stopHands(); // â† å°±é€™ä¸€è¡Œ

  // åœæ­¢ COSMOS å‹•ç•«
  animating = false;
  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = null;
  }

  // å•Ÿå‹• FINAL ä¸­å¤®è§’è‰²
  initFinalCharacter();
  startFinalCharacter();

  // å³å´æ–‡å­—ï¼ˆä¹‹å¾Œæœƒæ”¹æˆ sheet è®€ï¼‰
  document.getElementById("final-title").textContent =
    "GENETIC PROFILE Â· A01";

  document.getElementById("final-text").textContent =
    "Your biological resonance indicates high adaptability and strong cosmic synchronization.\nFurther evolution recommended.";
}


          // â˜… å•Ÿå‹•å·¦é‚Šä¸‰æ ¼å‹•ç•«
  startDNA();
  startGrid();
  startHeartbeat();

        document.getElementById("final-title").textContent =
          "GENETIC PROFILE Â· A01";

        document.getElementById("final-text").textContent =
          "Your biological resonance indicates high adaptability and strong cosmic synchronization.\nFurther evolution recommended.";
      }
    );

   // ================= é¡è‰²åŒæ­¥ï¼ˆCOSMOS + FINALï¼‰ =================
onValue(ref(db,"session"), s => {
  const session = s.val();
  if (!session || !session.color) return;

  colorHex = session.color;

  // COSMOS ç²’å­
  if (particles) {
    particles.material.color.set(colorHex);
  }

  // FINAL è§’è‰²ï¼ˆèº«é«” + è‡‰ï¼‰
  if (finalParticles) {
    finalParticles.body.material.color.set(colorHex);
    finalParticles.face.material.color.set(colorHex);
  }

  console.log("ğŸ¨ color updated:", colorHex);
});


// ===== æ¸¬è©¦ï¼šå¾ GAS è®€è³‡æ–™ â†’ å¯«å…¥ Firebase session =====
async function testLoadSession(id) {
  const res = await fetch(
    "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + id
  );
  const data = await res.json();

  console.log("GAS data:", data);

  if (data && data.id) {
    await set(ref(db, "session"), data);
    console.log("session written:", data);
  }
}

// ğŸ”§ æš«æ™‚æ›åœ¨ windowï¼Œæ–¹ä¾¿åœ¨ console å‘¼å«
window.testLoadSession = testLoadSession;

// ================= æ‰‹æ©Ÿæ§åˆ¶æŒ‡ä»¤ç›£è½ =================
onValue(ref(db, "control"), async (s) => {
  const cmd = s.val();
  if (!cmd || !cmd.action) return;

  console.log("ğŸ“± control command:", cmd);

  // ğŸ”„ RESETï¼šå›åˆ° IDLE
  if (cmd.action === "RESET") {
    await set(ref(db, "runtime/state"), STATES.IDLE);
    await set(ref(db, "session"), null);
    return;
  }

  // â–¶ STARTï¼šIDLE â†’ LOADING â†’ COSMOS
  if (cmd.action === "START" && cmd.code) {
    // 1. é€² LOADING
    await set(ref(db, "runtime/state"), STATES.LOADING);

    // 2. è®€ Sheetï¼ˆä½ å·²é©—è­‰æˆåŠŸçš„ GASï¼‰
    const res = await fetch(
      "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code="
      + cmd.code
    );
    const data = await res.json();

    console.log("ğŸ“„ sheet data:", data);

    if (data && data.id) {
      // 3. å¯« session
      await set(ref(db, "session"), data);

      // 4. é€² COSMOS
      await set(ref(db, "runtime/state"), STATES.COSMOS);
    }
    return;
  }

  // â–¶ FINALï¼šCOSMOS â†’ FINAL
  if (cmd.action === "FINAL") {
    await set(ref(db, "runtime/state"), STATES.FINAL);
    return;
  }
});

    // ================= MediaPipe Handsï¼ˆCOSMOS å°ˆç”¨ï¼‰ =================
let hands = null;
let mpCamera = null;
let handActive = false;

function initHands(videoEl) {
  if (hands) return;

  hands = new Hands({
    locateFile: file =>
      `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });

hands.onResults(results => {
  if (results.multiHandLandmarks?.length) {
    morphStrength = 1;
    console.log("âœŠ hand â†’ morph 1");
  } else {
    morphStrength = 0;
    console.log("âœ‹ no hand â†’ morph 0");
  }
});


  mpCamera = new Camera(videoEl, {
    onFrame: async () => {
      await hands.send({ image: videoEl });
    },
    width: 640,
    height: 480
  });

  mpCamera.start();
}
function stopHands() {
  if (mpCamera) {
    mpCamera.stop();
    mpCamera = null;
  }

  if (hands) {
    hands.close();
    hands = null;
  }

  handActive = false;
  console.log("ğŸ›‘ Hands stopped");
}


  </script>
</body>
</html>
