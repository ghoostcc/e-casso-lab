<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>E-casso Lab</title>

  <!-- Three.jsï¼ˆå…¨åŸŸï¼‰ -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <!-- âœ…âœ…âœ… æ­¥é©Ÿ 1: åŠ å…¥ MediaPipe CDNï¼ˆåœ¨ </head> ä¹‹å‰ï¼‰ âœ…âœ…âœ… -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <!-- âœ…âœ…âœ… æ­¥é©Ÿ 1 çµæŸ âœ…âœ…âœ… -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
    }

    /* âœ… ç–Šå±¤ï¼šç¢ºä¿ç•«é¢åˆ‡æ›ä¸æœƒäº’ç›¸è“‹ä½ */
    #idle    { z-index: 1; }
    #loading { z-index: 2; }
    #cosmos  { z-index: 3; }  /* COSMOS */
    #final   { z-index: 4; }  /* âœ… FINAL è¦åœ¨æœ€ä¸Š */

    .screen {
      display: none;
      position: fixed;
      inset: 0;

      /* âœ… å…¶ä»–ç•«é¢é è¨­ç½®ä¸­ï¼ˆFINAL æœƒè‡ªå·±è¦†è“‹ï¼‰ */
      align-items: center;
      justify-content: center;
    }

    .screen.active {
      display: flex;
    }

    /* ================= IDLE ================= */
    #idle {
      background-image: url("./bg_idle.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: contain;
      background-color: black;
    }

    #scan-overlay {
      position: absolute;
      left: 30%;
      top: 72%;
      width: 36%;
      height: 18%;
      overflow: hidden;
      pointer-events: none;
    }

    #scan-overlay video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.9;
    }

    .scan-line {
      position: absolute;
      top: -30%;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(
        to bottom,
        transparent,
        rgba(255,255,255,0.7),
        transparent
      );
      animation: scanMove 2.5s linear infinite;
    }

    @keyframes scanMove {
      from { top: -30%; }
      to   { top: 100%; }
    }

    /* ================= LOADING ================= */
    .loading-container {
      width: 60%;
      max-width: 800px;
      color: #7ffcff;
      font-family: monospace;
    }

    .progress-bar {
      width: 100%;
      height: 16px;
      border: 1px solid #7ffcff;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(
        90deg,
        transparent,
        #7ffcff,
        transparent
      );
      transition: width 0.6s ease;
    }
    /* ================= COSMOS ================= */
    /* âœ… COSMOSï¼šè®“ canvas å……æ»¿æ•´å€‹ç•«é¢ */
    #cosmos.active {
      display: block;
      background: black;
    }
    #cosmos canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
  /* âœ…âœ…âœ… æ­¥é©Ÿ 2: åŠ å…¥ COSMOS æ‰‹å‹¢ UI æ¨£å¼ âœ…âœ…âœ… */
    #cosmos-hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 10;
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #7ffcff;
      font-size: 14px;
      color: #7ffcff;
      font-family: monospace;
      display: none;
    }
    #cosmos.active #cosmos-hud {
      display: block;
    }
    .hud-value {
      font-weight: bold;
      color: #7ffcff;
    }

    #cosmos-camera {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 160px;
      height: 120px;
      transform: scaleX(-1);
      opacity: 0.3;
      border: 1px solid #7ffcff;
      z-index: 10;
      display: none;
    }
    #cosmos.active #cosmos-camera {
      display: block;
    }
    /* âœ…âœ…âœ… æ­¥é©Ÿ 2 çµæŸ âœ…âœ…âœ… */
    
    #debug {
      position: fixed;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #888;
      z-index: 9999;
    }

    /* ================= FINAL ================= */
    #final{
      /* âœ… èƒŒæ™¯ HUD */
      background: url("./final_bg.png") center center / contain no-repeat;
      color: #7ffcff;

      /* âœ… è®“ absolute å­å…ƒç´ ä»¥ FINAL ç‚ºåŸºæº– */
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    /* âœ… æ–·æ ¹ï¼šFINAL ä¸èƒ½è¢« .screen.active çš„ flex å½±éŸ¿ */
    #final.active{
      display: block !important;
    }

    /* âœ… è®“ FINAL ä¸åƒ screen çš„ç½®ä¸­å±¬æ€§ */
    #final{
      align-items: unset !important;
      justify-content: unset !important;
    }

/* å·¦å´ BIO å€ï¼ˆé€™å€‹å®¹å™¨åªç•¶å®šä½åƒè€ƒï¼Œä¸è¦å†ç”¨ flexï¼‰ */
.final-left{
  position: absolute;
  inset: 0;              /* è®“å®ƒè·Ÿ final ä¸€æ¨£å¤§ï¼Œæ–¹ä¾¿ç”¨ top/left å°é½Š */
  pointer-events: none;
}

/* ä¸‰å€‹æ´ï¼šå…±åŒè¨­å®š */
.bio-slot{
  position: absolute;
  overflow: hidden;      /* ä¿è­‰å‹•ç•«ä¸æœƒæº¢å‡ºæ¡†å¤– */
}

/* Canvas å¡«æ»¿æ´ */
.bio-slot canvas{
  width: 100%;
  height: 100%;
  display: block;
}

/* ========= ä¸‰å€‹æ´çš„ä½ç½®ï¼ˆä½ åªè¦èª¿é€™è£¡ï¼‰ ========= */
/* ä¸Šæ¡†ï¼šDNA */
.bio-slot-1{
  left: 350px;     /* âœ… å·¦å³ä½ç½®å¾®èª¿ */
  top: 250px;     /* âœ… ä¸Šä¸‹ä½ç½®å¾®èª¿ */
  width: 320px;   /* âœ… å¯¬åº¦å¾®èª¿ */
  height: 150px;  /* âœ… é«˜åº¦å¾®èª¿ */
}

/* ä¸­æ¡†ï¼šGrid */
.bio-slot-2{
  left: 350px;
  top: 430px;
  width: 320px;
  height: 200px;
}

/* ä¸‹æ¡†ï¼šHeartbeat */
.bio-slot-3{
  left: 330px;
  top: 688px;
  width: 260px;
  height: 120px;
}

    /* ä¸­å¤®ä¿ç•™çµ¦ COSMOSï¼ˆä¸ç”¨æ”¾å…§å®¹ï¼‰ */
    /* FINAL ä¸­å¤®è§’è‰²ï¼ˆCanvas ç²’å­ï¼‰ */
.final-center {
  position: absolute;
  left: 22%;
  top: 0;
  width: 52%;
  height: 100%;
  pointer-events: none;
}

#finalCharacter {
  position: absolute;
  left: 50%;
  top: 52%;
  transform: translate(-50%, -50%);
  width: 320px;
  height: 420px;
}


    /* âœ… å³å´ Conclusionï¼šè²¼é€²å³å´æ¡† */
    .final-right{
      position: absolute !important;
      top: 180px;
      right: 289px;
      width: 380px;

      color: #7ffcff;
      font-family: monospace;
      text-shadow: 0 0 8px rgba(0,255,255,0.25);
    }

    .final-right h2{
      margin: 0;
      font-size: 20px;
      letter-spacing: 2px;
    }

    .final-right p{
      margin-top: 18px;
      font-size: 14px;
      line-height: 1.7;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>

  <!-- IDLE -->
  <div id="idle" class="screen active">
    <div id="scan-overlay">
      <video id="camera" autoplay muted playsinline></video>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="loading" class="screen">
    <div class="loading-container">
      <div id="loading-text">åˆå§‹åŒ–ä¸­â€¦</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div id="progress-percent">0%</div>
    </div>
  </div>

  <!-- âœ…âœ…âœ… æ­¥é©Ÿ 3: åœ¨ COSMOS åŠ å…¥æ‰‹å‹¢ UI å…ƒç´  âœ…âœ…âœ… -->
  <div id="cosmos" class="screen">
    <!-- æ‰‹å‹¢ HUD -->
    <div id="cosmos-hud">
      <div>æ‰‹å‹¢: <span id="gesture" class="hud-value">ç­‰å¾…ä¸­...</span></div>
      <div>æ‰‹æŒ‡æ•¸: <span id="fingers" class="hud-value">0</span></div>
      <div>æ¨¡å¼: <span id="mode" class="hud-value">è§’è‰²é¡¯ç¤º</span></div>
    </div>
    <!-- æ‰‹å‹¢æ”å½±æ©Ÿï¼ˆå°è¦–çª—ï¼‰ -->
    <video id="cosmos-camera" autoplay muted playsinline></video>
  </div>
  <!-- âœ…âœ…âœ… æ­¥é©Ÿ 3 çµæŸ âœ…âœ…âœ… -->

<!-- FINAL -->
<div id="final" class="screen">

  <!-- å·¦å´ BIO ä¸‰æ ¼å‹•ç•« -->
  <div class="final-left">
  <div class="bio-slot bio-slot-1"><canvas id="dnaCanvas"></canvas></div>
  <div class="bio-slot bio-slot-2"><canvas id="gridCanvas"></canvas></div>
  <div class="bio-slot bio-slot-3"><canvas id="heartCanvas"></canvas></div>
</div>


  <!-- ä¸­å¤®ï¼ˆCOSMOS ç”¨ï¼‰ -->
  <div class="final-center">
</div>


  <!-- å³å´ Conclusion -->
  <div class="final-right">
    <h2 id="final-title">GENETIC ANALYSIS</h2>
    <p id="final-text">Awaiting biological conclusion...</p>
  </div>

</div>


  <div id="debug">state: â€”</div>

  <script type="module">
    const THREE = window.THREE;

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    
    const app = initializeApp({
      apiKey: "AIzaSyAoH3O3t8SYirmcCPVDG19bVC_Nh2VrAQc",
      authDomain: "e-casso-lab.firebaseapp.com",
      databaseURL: "https://e-casso-lab-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "e-casso-lab",
      storageBucket: "e-casso-lab.firebasestorage.app",
      messagingSenderId: "338061345474",
      appId: "1:338061345474:web:60a9b6c2a6d03e131e715b"
    });
    const db = getDatabase(app);

    const STATES = {
      IDLE: "IDLE",
      LOADING: "LOADING",
      COSMOS: "COSMOS",
      FINAL: "FINAL"
    };

    /* ================= FINAL CHARACTER (globals) ================= */
let finalScene = null;
let finalCamera = null;
let finalRenderer = null;
let finalParticles = null;
let finalTargets = [];

let finalRAF = null;
let finalAnimating = false;

    /* ================= é¡é ­ ================= */
    let camStream = null;
    const video = document.getElementById("camera");

    function startCamera() {
  const video = document.getElementById("camera");
  if (!video) {
    console.warn("camera element not ready");
    return;
  }
  if (camStream) return;

  navigator.mediaDevices.getUserMedia({ video:true })
    .then(s=>{
      camStream = s;
      video.srcObject = s;
    })
    .catch(err=>{
      console.warn("camera error:", err);
    });
}

   function stopCamera() {
  const video = document.getElementById("camera");
  if (!camStream) return;

  camStream.getTracks().forEach(t=>t.stop());
  camStream = null;
  if (video) video.srcObject = null;
}

    /* âœ…âœ…âœ… æ­¥é©Ÿ 4: åŠ å…¥æ‰‹å‹¢è¿½è¹¤è®Šæ•¸ï¼ˆåœ¨ COSMOS è®Šæ•¸å€å¡Šï¼‰ âœ…âœ…âœ… */
    let cosmosHandStream = null;
    let cosmosHands = null;
    let cosmosCamera = null;
    let handData = null;
    let scatterTargets = [];
    let gatherPoint = null;
    /* âœ…âœ…âœ… æ­¥é©Ÿ 4 çµæŸ âœ…âœ…âœ… */
    
    /* ================= COSMOS ================= */
    let scene, camera3D, renderer, particles;
    let animating = false;
    let colorHex = "#66ffff";
    let characterTargets = [];
    let morphStrength = 0;
    let rafId = null;

     /* âœ…âœ…âœ… æ­¥é©Ÿ 5: åŠ å…¥æ‰‹å‹¢åµæ¸¬å‡½æ•¸ï¼ˆåœ¨ COSMOS å€å¡Šå¾Œé¢ï¼‰ âœ…âœ…âœ… */
    // æ‰‹å‹¢åµæ¸¬æ ¸å¿ƒ
    function countFingers(landmarks) {
      let count = 0;
      
      if (landmarks[8].y < landmarks[6].y) count++;
      if (landmarks[12].y < landmarks[10].y) count++;
      if (landmarks[16].y < landmarks[14].y) count++;
      if (landmarks[20].y < landmarks[18].y) count++;
      
      const wrist = landmarks[0];
      const indexMCP = landmarks[5];
      const thumbTip = landmarks[4];
      const scale = Math.hypot(indexMCP.x - wrist.x, indexMCP.y - wrist.y);
      const thumbDist = Math.hypot(thumbTip.x - indexMCP.x, thumbTip.y - indexMCP.y);
      
      if (thumbDist > scale * 0.5) count++;
      
      return count;
    }

    // æ‰‹å‹¢çµæœè™•ç†
    function onHandResults(results) {
      handData = null;
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const fingerCount = countFingers(landmarks);
        handData = { landmarks, fingerCount };
        
        document.getElementById('fingers').innerText = fingerCount;
        
        if (fingerCount >= 4) {
          document.getElementById('gesture').innerText = 'å¼µé–‹æ‰‹æŒ';
          document.getElementById('mode').innerText = 'ç²’å­åˆ†æ•£';
          setScatterMode();
        } else if (fingerCount <= 1) {
          document.getElementById('gesture').innerText = 'æ¡æ‹³';
          document.getElementById('mode').innerText = 'èšåˆåˆ°æ‰‹æŒ';
          setGatherMode();
        } else {
          document.getElementById('gesture').innerText = 'éƒ¨åˆ†å¼µé–‹';
          document.getElementById('mode').innerText = 'é¡¯ç¤ºè§’è‰²';
          morphStrength = 1;
        }
      } else {
        document.getElementById('gesture').innerText = 'æœªåµæ¸¬';
        document.getElementById('mode').innerText = 'é¡¯ç¤ºè§’è‰²';
        morphStrength = 1;
      }
    }

    // ç²’å­åˆ†æ•£æ¨¡å¼
    function setScatterMode() {
      const w = window.innerWidth * 1.2;
      const h = window.innerHeight * 1.2;
      const d = 800;
      
      if (scatterTargets.length === 0) {
        for (let i = 0; i < 24000; i++) {
          scatterTargets.push({
            x: (Math.random() - 0.5) * w,
            y: (Math.random() - 0.5) * h,
            z: (Math.random() - 0.5) * d
          });
        }
      }
      
      morphStrength = 0;
    }

    // ç²’å­èšåˆæ¨¡å¼
    function setGatherMode() {
      if (!handData || !particles) return;
      
      const vFOV = THREE.MathUtils.degToRad(camera3D.fov);
      const heightAtZ0 = 2 * Math.tan(vFOV / 2) * camera3D.position.z;
      const widthAtZ0 = heightAtZ0 * camera3D.aspect;
      
      const palmCenter = handData.landmarks[9];
      const centerX = -(palmCenter.x - 0.5) * widthAtZ0;
      const centerY = -(palmCenter.y - 0.5) * heightAtZ0;
      
      morphStrength = -1;
      gatherPoint = { x: centerX, y: centerY, z: 0 };
    }

    // å•Ÿå‹•æ‰‹å‹¢è¿½è¹¤
    function startCosmosHandTracking() {
      if (cosmosHands) return;
      
      const videoElement = document.getElementById('cosmos-camera');
      
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          cosmosHandStream = stream;
          videoElement.srcObject = stream;
        })
        .catch(err => {
          console.warn("COSMOS æ‰‹å‹¢æ”å½±æ©ŸéŒ¯èª¤:", err);
        });
      
      cosmosHands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      
      cosmosHands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });
      
      cosmosHands.onResults(onHandResults);
      
      cosmosCamera = new Camera(videoElement, {
        onFrame: async () => {
          await cosmosHands.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });
      
      cosmosCamera.start();
      console.log("âœ… COSMOS æ‰‹å‹¢è¿½è¹¤å·²å•Ÿå‹•");
    }

    // åœæ­¢æ‰‹å‹¢è¿½è¹¤
    function stopCosmosHandTracking() {
      if (cosmosHandStream) {
        cosmosHandStream.getTracks().forEach(t => t.stop());
        cosmosHandStream = null;
      }
      if (cosmosCamera) {
        cosmosCamera.stop();
        cosmosCamera = null;
      }
      cosmosHands = null;
      handData = null;
      document.getElementById('cosmos-camera').srcObject = null;
      console.log("âŒ COSMOS æ‰‹å‹¢è¿½è¹¤å·²åœæ­¢");
    }
    /* âœ…âœ…âœ… æ­¥é©Ÿ 5 çµæŸ âœ…âœ…âœ… */
    
    function initCosmos() {
      if (scene) return;

      console.log("åˆå§‹åŒ– COSMOS...");

      scene = new THREE.Scene();
      camera3D = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
      camera3D.position.z = 350;

      renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 1);

      const cosmosEl = document.getElementById("cosmos");
      cosmosEl.innerHTML = "";
      cosmosEl.appendChild(renderer.domElement);

      renderer.render(scene, camera3D);

      const count = 24000;
      const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        pos[i*3]=(Math.random()-0.5)*500;
        pos[i*3+1]=(Math.random()-0.5)*500;
        pos[i*3+2]=(Math.random()-0.5)*500;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

      const mat = new THREE.PointsMaterial({
        color:new THREE.Color(colorHex),
        size:1.3,
        transparent:true,
        opacity:0.85,
        blending:THREE.AdditiveBlending
      });

      particles = new THREE.Points(geo,mat);
      scene.add(particles);

      console.log("ç²’å­ç³»çµ±å»ºç«‹å®Œæˆ");

      loadCharacterPoints("./character.png").then(() => {
        console.log("è§’è‰²é»é›²æº–å‚™å®Œæˆï¼Œé–‹å§‹å‹•ç•«");
        if (animating) startAnimateLoop();
      }).catch(() => {
        console.warn("è§’è‰²é»é›²å¤±æ•—ï¼ˆä»å¯é¡¯ç¤ºæ¼‚æµ®ç²’å­ï¼‰");
        if (animating) startAnimateLoop();
      });
    }

    function loadCharacterPoints(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = src;

        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          const targetSize = 160;
          canvas.width = targetSize;
          canvas.height = targetSize;
          ctx.drawImage(img, 0, 0, targetSize, targetSize);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          characterTargets = [];
          const displayScale = 280;

          for(let y=0; y<canvas.height; y++){
            for(let x=0; x<canvas.width; x++){
              const i=(y*canvas.width+x)*4;
              const r = data[i], g = data[i+1], b = data[i+2], alpha = data[i+3];

              const brightness = (r + g + b) / 3;
              const isFace = brightness > 100;

              if ((isFace && alpha > 5) || (!isFace && alpha > 30)) {
                const baseX = (x / canvas.width - 0.5) * displayScale;
                const baseY = -(y / canvas.height - 0.5) * displayScale;

                characterTargets.push({ x: baseX, y: baseY, z: 0 });

                if (isFace && alpha > 50) {
                  if (Math.random() > 0.2) characterTargets.push({ x: baseX + (Math.random()-0.5)*2.5, y: baseY + (Math.random()-0.5)*2.5, z: (Math.random()-0.5)*12 });
                  if (Math.random() > 0.3) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.0, y: baseY + (Math.random()-0.5)*3.0, z: (Math.random()-0.5)*15 });
                  if (brightness > 150 && Math.random() > 0.4) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.5, y: baseY + (Math.random()-0.5)*3.5, z: (Math.random()-0.5)*18 });
                } else if (!isFace && alpha > 200 && Math.random() > 0.7) {
                  characterTargets.push({ x: baseX + (Math.random()-0.5)*1.5, y: baseY + (Math.random()-0.5)*1.5, z: (Math.random()-0.5)*6 });
                }
              }
            }
          }

          console.log(`å¾åœ–ç‰‡ç”Ÿæˆ ${characterTargets.length} å€‹ç›®æ¨™é»`);
          resolve();
        };

        img.onerror = (e) => {
          console.error("åœ–ç‰‡è¼‰å…¥å¤±æ•—:", src, e);
          reject(e);
        };
      });
    }

   /* âœ…âœ…âœ… æ­¥é©Ÿ 6: ä¿®æ”¹å‹•ç•«å¾ªç’°ï¼ˆæ›¿æ›åŸæœ¬çš„ startAnimateLoopï¼‰âœ…âœ…âœ… */
    function startAnimateLoop() {
      if (rafId) cancelAnimationFrame(rafId);

      const loop = () => {
        if (!animating || !particles) return;

        const p = particles.geometry.attributes.position.array;
        const time = Date.now() * 0.0003;

        // æ¡æ‹³ = èšåˆåˆ°æ‰‹æŒ
        if (morphStrength === -1 && gatherPoint) {
          for (let i = 0; i * 3 < p.length; i++) {
            const idx = i * 3;
            const noise = 80;
            
            const tx = gatherPoint.x + (Math.random() - 0.5) * noise;
            const ty = gatherPoint.y + (Math.random() - 0.5) * noise;
            const tz = gatherPoint.z + (Math.random() - 0.5) * noise;
            
            p[idx]     += (tx - p[idx]) * 0.12;
            p[idx + 1] += (ty - p[idx + 1]) * 0.12;
            p[idx + 2] += (tz - p[idx + 2]) * 0.12;
          }
        }
        // å¼µé–‹æ‰‹æŒ = åˆ†æ•£
        else if (morphStrength === 0 && scatterTargets.length > 0) {
          for (let i = 0; i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = scatterTargets[i] || scatterTargets[0];
            
            p[idx]     += (t.x - p[idx]) * 0.08;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.08;
            p[idx + 2] += (t.z - p[idx + 2]) * 0.08;
          }
        }
        // é¡¯ç¤ºè§’è‰²ï¼ˆåŸæœ¬çš„é‚è¼¯ï¼‰
        else if (morphStrength === 1 && characterTargets.length > 0) {
          for (let i = 0; i < characterTargets.length && i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = characterTargets[i];
            const breathe = Math.sin(time + i * 0.01) * 0.3;

            p[idx]     += (t.x - p[idx])     * 0.06;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.06;
            p[idx + 2] += (t.z + breathe - p[idx + 2]) * 0.06;
          }

          for (let i = characterTargets.length; i * 3 < p.length; i++) {
            const idx = i * 3;
            p[idx]     += Math.sin(time + i * 0.1) * 0.04;
            p[idx + 1] += Math.cos(time + i * 0.15) * 0.04;
            p[idx + 2] += Math.sin(time + i * 0.2) * 0.04;
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.002;

        renderer.render(scene, camera3D);
        rafId = requestAnimationFrame(loop);
      };

      rafId = requestAnimationFrame(loop);
    }
    /* âœ…âœ…âœ… æ­¥é©Ÿ 6 çµæŸ âœ…âœ…âœ… */


    function startDNA(){
  const c = document.getElementById("dnaCanvas");
  if (!c) return;
  const ctx = c.getContext("2d");

  function resize(){
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let t = 0;
  function loop(){
    ctx.clearRect(0,0,c.width,c.height);
    ctx.strokeStyle = "#7ffcff";
    ctx.lineWidth = 1;

    for(let y=0; y<c.height; y+=3){
      const wave = Math.sin(y*0.05 + t) * 30;
      ctx.beginPath();
      ctx.moveTo(c.width/2 + wave, y);
      ctx.lineTo(c.width/2 - wave, y);
      ctx.stroke();
    }

    t += 0.03;
    requestAnimationFrame(loop);
  }
  loop();
}

function startGrid(){
  const c = document.getElementById("gridCanvas");
  if (!c) return;
  const ctx = c.getContext("2d");

  function resize(){
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const dots = Array.from({length:100},()=>({
    x: Math.random()*c.width,
    y: Math.random()*c.height,
    a: Math.random()
  }));

  function loop(){
    ctx.clearRect(0,0,c.width,c.height);

    ctx.strokeStyle = "rgba(127,252,255,0.15)";
    for(let x=0;x<c.width;x+=20){
      ctx.beginPath();
      ctx.moveTo(x,0);
      ctx.lineTo(x,c.height);
      ctx.stroke();
    }
    for(let y=0;y<c.height;y+=20){
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(c.width,y);
      ctx.stroke();
    }

    dots.forEach(d=>{
      d.a += (Math.random()-0.5)*0.1;
      d.a = Math.max(0,Math.min(1,d.a));
      ctx.fillStyle = `rgba(127,252,255,${d.a})`;
      ctx.fillRect(d.x,d.y,2,2);
    });

    requestAnimationFrame(loop);
  }
  loop();
}

function startHeartbeat(){
  const c = document.getElementById("heartCanvas");
  if (!c) return;
  const ctx = c.getContext("2d");

  function resize(){
    c.width = c.clientWidth;
    c.height = c.clientHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let t = 0;
  function loop(){
    ctx.clearRect(0,0,c.width,c.height);
    ctx.strokeStyle = "#7ffcff";
    ctx.lineWidth = 2;
    ctx.beginPath();

    for(let x=0;x<c.width;x++){
      let y =
        c.height/2 +
        Math.sin((x+t)*0.05)*8 +
        (x%120<10 ? -25 : 0);

      ctx.lineTo(x,y);
    }

    ctx.stroke();
    t += 4;
    requestAnimationFrame(loop);
  }
  loop();
}

    /* ================= LOADING ================= */
    function startLoadingSequence() {
      const steps=[
        {t:"åˆå§‹åŒ–ä¸­â€¦",p:10},
        {t:"å§“åæ ¸å°ä¸­",p:40},
        {t:"è³‡æ–™ç¢ºèªä¸­",p:75},
        {t:"æº–å‚™å®Œæˆ",p:100}
      ];
      let i=0;
      const txt=document.getElementById("loading-text");
      const fill=document.getElementById("progress-fill");
      const per=document.getElementById("progress-percent");

      fill.style.width="0%";
      per.textContent="0%";

      function next(){
        if(i>=steps.length)return;
        txt.textContent=steps[i].t;
        fill.style.width=steps[i].p+"%";
        per.textContent=steps[i].p+"%";
        i++;
        setTimeout(next,600);
      }
      setTimeout(next,150);
    }

// ================= FINAL ä¸­å¤®è§’è‰²ï¼ˆä¸€æ¬¡æˆå‹ï¼Œä¸ç™¼æ•£ï¼‰ =================
function initFinalCharacter() {
  if (finalScene) return;

  // --- Scene ---
  finalScene = new THREE.Scene();

  // --- Cameraï¼ˆFINAL å°ˆç”¨ï¼Œè¼ƒè¿‘ã€ä¸åƒæ•´å€‹ç•«é¢ï¼‰ ---
  finalCamera = new THREE.PerspectiveCamera(
    50,
    1,        // å…ˆçµ¦ 1ï¼Œä¸‹é¢æœƒç”¨ container é‡ç®—
    1,
    1000
  );
  finalCamera.position.z = 180; // â† æ§åˆ¶è§’è‰²é è¿‘ï¼ˆ150~220ï¼‰

  // --- Renderer ---
  finalRenderer = new THREE.WebGLRenderer({
    alpha: true,
    antialias: true
  });
  finalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // âœ… åªåƒ FINAL ä¸­å¤®æ¡†
  const container = document.querySelector(".final-center");
  const w = container.clientWidth;
  const h = container.clientHeight;

  finalRenderer.setSize(w, h);
  finalCamera.aspect = w / h;
  finalCamera.updateProjectionMatrix();

  container.innerHTML = "";
  container.appendChild(finalRenderer.domElement);

  // --- è¼‰å…¥è§’è‰²é»é›²ï¼ˆä¸€é–‹å§‹å°±æˆäººå‹ï¼‰ ---
loadFinalCharacterPoints("./character.png").then(() => {

  // â‘  åˆ†é¡ï¼šèº«é«” / è‡‰
  const body = [];
  const face = [];

  finalTargets.forEach(t => {
    if (t.face) face.push(t);
    else body.push(t);
  });

  /* ================= èº«é«” ================= */

  const bodyPos = new Float32Array(body.length * 3);
  body.forEach((t, i) => {
    bodyPos[i*3]   = t.x + 25;
    bodyPos[i*3+1] = t.y + 40;
    bodyPos[i*3+2] = t.z;
  });

  const bodyGeo = new THREE.BufferGeometry();
  bodyGeo.setAttribute("position", new THREE.BufferAttribute(bodyPos, 3));

  const bodyMat = new THREE.PointsMaterial({
    color: new THREE.Color(colorHex),
    size: 0.7,
    transparent: true,
    opacity: 0.55,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const bodyPoints = new THREE.Points(bodyGeo, bodyMat);
  finalScene.add(bodyPoints);

  /* ================= è‡‰ ================= */

  const facePos = new Float32Array(face.length * 3);
  face.forEach((t, i) => {
    facePos[i*3]   = t.x + 25;
    facePos[i*3+1] = t.y + 40;
    facePos[i*3+2] = t.z; // z å·²ç¶“åœ¨ç”¢ç”Ÿæ™‚å¾€å‰
  });

  const faceGeo = new THREE.BufferGeometry();
  faceGeo.setAttribute("position", new THREE.BufferAttribute(facePos, 3));

  const faceMat = new THREE.PointsMaterial({
    color: new THREE.Color(colorHex),
    size: 1.0,          // âœ… è‡‰æ¯”è¼ƒå¤§
    transparent: true,
    opacity: 0.85,      // âœ… è‡‰æ¯”è¼ƒäº®
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const facePoints = new THREE.Points(faceGeo, faceMat);
  finalScene.add(facePoints);

  // æ•´é«”å¤§å°ï¼ˆå…©å±¤ä¸€èµ·ï¼‰
  bodyPoints.scale.set(0.35, 0.35, 0.35);
  facePoints.scale.set(0.35, 0.35, 0.35);

  finalRenderer.render(finalScene, finalCamera);
});
}


// ================= å¾åœ–ç‰‡ç”Ÿæˆ FINAL è§’è‰²é»ï¼ˆä¿®æ­£ç‰ˆï¼‰ =================
function loadFinalCharacterPoints(src) {
  return new Promise(resolve => {
    const img = new Image();
    img.src = src;

    img.onload = () => {
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");

      const size = 240;
      c.width = size;
      c.height = size;
      ctx.drawImage(img, 0, 0, size, size);

      const data = ctx.getImageData(0, 0, size, size).data;
      finalTargets = [];

      const scale = 220;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const i = (y * size + x) * 4;

          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const alpha = data[i + 3];
          const brightness = (r + g + b) / 3;

          if (alpha < 50) continue;

          const px = (x / size - 0.5) * scale;
          const py = -(y / size - 0.5) * scale;

// ğŸ‘¤ è‡‰éƒ¨å¼·åŒ–ï¼ˆæ¨™è¨˜ç‚º faceï¼‰
if (brightness > 165 && alpha > 60) {

  // æ ¸å¿ƒè‡‰
  if (Math.random() > 0.1) {
    finalTargets.push({
      x: (x / size - 0.5) * scale,
      y: -(y / size - 0.5) * scale,
      z: 3,              // âœ… è‡‰æ›´å‰
      face: true         // âœ… é—œéµæ¨™è¨˜
    });
  }

  // è¼ªå»“è£œé»
  if (Math.random() > 0.6) {
    finalTargets.push({
      x: (x / size - 0.5) * scale + (Math.random() - 0.5) * 2,
      y: -(y / size - 0.5) * scale + (Math.random() - 0.5) * 2,
      z: 4,
      face: true
    });
  }
}


          // ğŸ§ èº«é«”ï¼ˆæš—è‰²ï¼‰â€” ä¸€å®šè¦æŠ½
          else {
            if (Math.random() < 0.22) {
              finalTargets.push({ x: px, y: py, z: 0 });
            }
          }
        }
      }

      resolve();
    };
  });
}



// FINAL å‹•ç•«ï¼ˆåªåšå¾®å‘¼å¸ï¼‰
function startFinalCharacter() {
  stopFinalCharacter();
  finalAnimating = true;

  const loop = () => {
    if (!finalAnimating || !finalParticles) return;

    const p = finalParticles.geometry.attributes.position.array;
    const t = Date.now() * 0.001;

    for (let i = 0; i * 3 < p.length; i++) {
      p[i * 3 + 2] += Math.sin(t + i * 0.02) * 0.03;
    }

    finalParticles.geometry.attributes.position.needsUpdate = true;
    finalRenderer.render(finalScene, finalCamera);
    finalRAF = requestAnimationFrame(loop);
  };

  loop();
}

// FINAL åœæ­¢ï¼ˆé›¢é–‹æ™‚ä¸€å®šè¦ï¼‰
function stopFinalCharacter() {
  finalAnimating = false;
  if (finalRAF) {
    cancelAnimationFrame(finalRAF);
    finalRAF = null;
  }
}


    function switchScreen(state) {
      document.querySelectorAll(".screen").forEach(el=>{
        el.classList.remove("active");
      });

      const target = document.getElementById(state.toLowerCase());
      if (target) target.classList.add("active");
    }

    /* ================= Firebase ç‹€æ…‹ ================= */
    onValue(ref(db,"runtime/state"), s=>{
      const state = s.val();
      document.getElementById("debug").textContent = `state: ${state}`;

      if (!state) return;
      switchScreen(state);

      if (state === STATES.IDLE) {
        stopFinalCharacter();
        stopCosmosHandTracking(); // âœ… åŠ é€™è¡Œ
        startCamera();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.LOADING) {
        stopFinalCharacter();
        stopCosmosHandTracking(); // âœ… åŠ é€™è¡Œ
        stopCamera();
        startLoadingSequence();
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.COSMOS) {
        stopFinalCharacter();
        stopCamera();
        initCosmos();

        animating = true;
        morphStrength = 0;

        startCosmosHandTracking(); // âœ… åŠ é€™è¡Œï¼šå•Ÿå‹•æ‰‹å‹¢è¿½è¹¤

        setTimeout(() => {
          morphStrength = 1;
        }, 1000);

        if (scene && !rafId) startAnimateLoop();
      }

else if (state === STATES.FINAL) {
  stopCamera();
  stopCosmosHandTracking();

  animating = false;
  if (rafId) {
    cancelAnimationFrame(rafId);
    rafId = null;
  }

  initFinalCharacter();
  startFinalCharacter();

  startDNA();
  startGrid();
  startHeartbeat();
}

          // â˜… å•Ÿå‹•å·¦é‚Šä¸‰æ ¼å‹•ç•«
  startDNA();
  startGrid();
  startHeartbeat();

 onValue(ref(db, "session"), snap => {
  const d = snap.val();
  if (!d) return;

  // ===== æ–‡å­— =====
  if (d.title) {
    const titleEl = document.getElementById("final-title");
    if (titleEl) titleEl.textContent = d.title;
  }

  if (d.conclusion) {
    const textEl = document.getElementById("final-text");
    if (textEl) textEl.textContent = d.conclusion;
  }

  // ===== é¡è‰² =====
  if (d.color) {
    colorHex = d.color;

    if (particles) {
      particles.material.color.set(colorHex);
    }

    if (finalParticles) {
      finalParticles.material.color.set(colorHex);
    }
  }
});


    set(ref(db,"runtime/state"),STATES.IDLE);

    addEventListener("keydown", e => {
      if (e.key === "1") set(ref(db,"runtime/state"), STATES.IDLE);
      if (e.key === "2") set(ref(db,"runtime/state"), STATES.LOADING);
      if (e.key === "3") set(ref(db,"runtime/state"), STATES.COSMOS);
      if (e.key === "4") set(ref(db,"runtime/state"), STATES.FINAL);
    });

    window.addEventListener("resize", () => {
      if (camera3D && renderer) {
        camera3D.aspect = window.innerWidth / window.innerHeight;
        camera3D.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    console.log("Three.js ç‰ˆæœ¬:", THREE.REVISION);
    console.log("åˆå§‹ç‹€æ…‹:", STATES.IDLE);

// ===== æ¸¬è©¦ï¼šå¾ GAS è®€è³‡æ–™ â†’ å¯«å…¥ Firebase session =====
async function testLoadSession(id) {
  const res = await fetch(
    "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + id
  );
  const data = await res.json();

  console.log("GAS data:", data);

  if (data && data.id) {
    await set(ref(db, "session"), data);
    console.log("session written:", data);
  }
}

// ğŸ”§ æš«æ™‚æ›åœ¨ windowï¼Œæ–¹ä¾¿åœ¨ console å‘¼å«
window.testLoadSession = testLoadSession;



  </script>
</body>
</html>


