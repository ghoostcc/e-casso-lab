<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>E-casso Lab</title>

  <!-- Three.jsÔºàÂÖ®ÂüüÔºâ -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: sans-serif;
    }

    /* ‚úÖ ÁñäÂ±§ÔºöÁ¢∫‰øùÁï´Èù¢ÂàáÊèõ‰∏çÊúÉ‰∫íÁõ∏Ëìã‰Ωè */
    #idle    { z-index: 1; }
    #loading { z-index: 2; }
    #cosmos  { z-index: 3; }  /* COSMOS */
    #final   { z-index: 4; }  /* ‚úÖ FINAL Ë¶ÅÂú®ÊúÄ‰∏ä */

    .screen {
      display: none;
      position: fixed;
      inset: 0;
      align-items: center;
      justify-content: center;
    }

    .screen.active {
      display: flex;
    }

    /* ================= IDLE ================= */
    #idle {
      background-image: url("./bg_idle.png");
      background-repeat: no-repeat;
      background-position: center center;
      background-size: contain;
      background-color: black;
    }

    #scan-overlay {
      position: absolute;
      left: 30%;
      top: 72%;
      width: 36%;
      height: 18%;
      overflow: hidden;
      pointer-events: none;
    }

    #scan-overlay video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.9;
    }

    .scan-line {
      position: absolute;
      top: -30%;
      left: 0;
      width: 100%;
      height: 30%;
      background: linear-gradient(
        to bottom,
        transparent,
        rgba(255,255,255,0.7),
        transparent
      );
      animation: scanMove 2.5s linear infinite;
    }

    @keyframes scanMove {
      from { top: -30%; }
      to   { top: 100%; }
    }

    /* ================= LOADING ================= */
    .loading-container {
      width: 60%;
      max-width: 800px;
      color: #7ffcff;
      font-family: monospace;
    }

    .progress-bar {
      width: 100%;
      height: 16px;
      border: 1px solid #7ffcff;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(
        90deg,
        transparent,
        #7ffcff,
        transparent
      );
      transition: width 0.6s ease;
    }

    /* ‚úÖ COSMOSÔºöËÆì canvas ÂÖÖÊªøÊï¥ÂÄãÁï´Èù¢ */
    #cosmos.active {
      display: block;
      background: black;
    }
    #cosmos canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    #debug {
      position: fixed;
      bottom: 10px;
      left: 10px;
      font-size: 12px;
      color: #888;
      z-index: 9999;
    }

    /* ================= FINAL ================= */
    #final{
      background: url("./final_bg.png") center center / contain no-repeat;
      color: #7ffcff;
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    /* ‚úÖ Êñ∑Ê†πÔºöFINAL ‰∏çËÉΩË¢´ .screen.active ÁöÑ flex ÂΩ±Èüø */
    #final.active{
      display: block !important;
    }

    /* ‚úÖ ËÆì FINAL ‰∏çÂêÉ screen ÁöÑÁΩÆ‰∏≠Â±¨ÊÄß */
    #final{
      align-items: unset !important;
      justify-content: unset !important;
    }

    /* Â∑¶ÂÅ¥ BIO ÂçÄ */
    .final-left{
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .bio-slot{
      position: absolute;
      overflow: hidden;
    }

    .bio-slot canvas{
      width: 100%;
      height: 100%;
      display: block;
    }

    .bio-slot-1{
      left: 350px;
      top: 250px;
      width: 320px;
      height: 150px;
    }

    .bio-slot-2{
      left: 350px;
      top: 430px;
      width: 320px;
      height: 200px;
    }

    .bio-slot-3{
      left: 330px;
      top: 688px;
      width: 260px;
      height: 120px;
    }

    .final-center {
      position: absolute;
      left: 22%;
      top: 0;
      width: 52%;
      height: 100%;
      pointer-events: none;
    }

    #finalCharacter {
      position: absolute;
      left: 50%;
      top: 52%;
      transform: translate(-50%, -50%);
      width: 320px;
      height: 420px;
    }

    .final-right{
      position: absolute !important;
      top: 180px;
      right: 289px;
      width: 380px;
      color: #7ffcff;
      font-family: monospace;
      text-shadow: 0 0 8px rgba(0,255,255,0.25);
    }

    .final-right h2{
      margin: 0;
      font-size: 20px;
      letter-spacing: 2px;
    }

    .final-right p{
      margin-top: 18px;
      font-size: 14px;
      line-height: 1.7;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>

  <!-- IDLE -->
  <div id="idle" class="screen active">
    <div id="scan-overlay">
      <video id="camera" autoplay muted playsinline></video>
      <div class="scan-line"></div>
    </div>
  </div>

  <!-- LOADING -->
  <div id="loading" class="screen">
    <div class="loading-container">
      <div id="loading-text">ÂàùÂßãÂåñ‰∏≠‚Ä¶</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <div id="progress-percent">0%</div>
    </div>
  </div>

  <!-- COSMOS -->
  <div id="cosmos" class="screen"></div>

  <!-- FINAL -->
  <div id="final" class="screen">
    <div class="final-left">
      <div class="bio-slot bio-slot-1"><canvas id="dnaCanvas"></canvas></div>
      <div class="bio-slot bio-slot-2"><canvas id="gridCanvas"></canvas></div>
      <div class="bio-slot bio-slot-3"><canvas id="heartCanvas"></canvas></div>
    </div>

    <div class="final-center"></div>

    <div class="final-right">
      <h2 id="final-title">GENETIC ANALYSIS</h2>
      <p id="final-text">Awaiting biological conclusion...</p>
    </div>
  </div>

  <div id="debug">state: ‚Äî</div>

  <script type="module">
    const THREE = window.THREE;

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

    const app = initializeApp({
      apiKey: "AIzaSyAoH3O3t8SYirmcCPVDG19bVC_Nh2VrAQc",
      authDomain: "e-casso-lab.firebaseapp.com",
      databaseURL: "https://e-casso-lab-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "e-casso-lab",
      storageBucket: "e-casso-lab.firebasestorage.app",
      messagingSenderId: "338061345474",
      appId: "1:338061345474:web:60a9b6c2a6d03e131e715b"
    });
    const db = getDatabase(app);

    const STATES = {
      IDLE: "IDLE",
      LOADING: "LOADING",
      COSMOS: "COSMOS",
      FINAL: "FINAL"
    };

    /* ================= FINAL CHARACTER (globals) ================= */
    let finalScene = null;
    let finalCamera = null;
    let finalRenderer = null;
    let finalParticles = null; // ‚úÖ ÊúÉÊòØ {body, face}
    let finalTargets = [];
    let finalRAF = null;
    let finalAnimating = false;

    /* ================= Èè°È†≠ ================= */
    let camStream = null;
    const video = document.getElementById("camera");

    function startCamera() {
      if (camStream) return;
      navigator.mediaDevices.getUserMedia({ video:true }).then(s=>{
        camStream = s;
        video.srcObject = s;
      }).catch(err=>{
        console.warn("camera error:", err);
      });
    }
    function stopCamera() {
      if (!camStream) return;
      camStream.getTracks().forEach(t=>t.stop());
      camStream = null;
      video.srcObject = null;
    }

    /* ================= COSMOS ================= */
    let scene, camera3D, renderer, particles;
    let animating = false;
    let colorHex = "#66ffff";
    let characterTargets = [];
    let morphStrength = 0;
    let rafId = null;

    function initCosmos() {
      if (scene) return;

      console.log("ÂàùÂßãÂåñ COSMOS...");

      scene = new THREE.Scene();
      camera3D = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
      camera3D.position.z = 350;

      renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 1);

      const cosmosEl = document.getElementById("cosmos");
      cosmosEl.innerHTML = "";
      cosmosEl.appendChild(renderer.domElement);

      renderer.render(scene, camera3D);

      const count = 24000;
      const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        pos[i*3]=(Math.random()-0.5)*500;
        pos[i*3+1]=(Math.random()-0.5)*500;
        pos[i*3+2]=(Math.random()-0.5)*500;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos,3));

      const mat = new THREE.PointsMaterial({
        color:new THREE.Color(colorHex),
        size:1.3,
        transparent:true,
        opacity:0.85,
        blending:THREE.AdditiveBlending
      });

      particles = new THREE.Points(geo,mat);
      scene.add(particles);

      console.log("Á≤íÂ≠êÁ≥ªÁµ±Âª∫Á´ãÂÆåÊàê");

      loadCharacterPoints("./character.png").then(() => {
        console.log("ËßíËâ≤ÈªûÈõ≤Ê∫ñÂÇôÂÆåÊàêÔºåÈñãÂßãÂãïÁï´");
        if (animating) startAnimateLoop();
      }).catch(() => {
        console.warn("ËßíËâ≤ÈªûÈõ≤Â§±ÊïóÔºà‰ªçÂèØÈ°ØÁ§∫ÊºÇÊµÆÁ≤íÂ≠êÔºâ");
        if (animating) startAnimateLoop();
      });
    }

    function loadCharacterPoints(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = src;

        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          const targetSize = 160;
          canvas.width = targetSize;
          canvas.height = targetSize;
          ctx.drawImage(img, 0, 0, targetSize, targetSize);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          characterTargets = [];
          const displayScale = 280;

          for(let y=0; y<canvas.height; y++){
            for(let x=0; x<canvas.width; x++){
              const i=(y*canvas.width+x)*4;
              const r = data[i], g = data[i+1], b = data[i+2], alpha = data[i+3];

              const brightness = (r + g + b) / 3;
              const isFace = brightness > 100;

              if ((isFace && alpha > 5) || (!isFace && alpha > 30)) {
                const baseX = (x / canvas.width - 0.5) * displayScale;
                const baseY = -(y / canvas.height - 0.5) * displayScale;

                characterTargets.push({ x: baseX, y: baseY, z: 0 });

                if (isFace && alpha > 50) {
                  if (Math.random() > 0.2) characterTargets.push({ x: baseX + (Math.random()-0.5)*2.5, y: baseY + (Math.random()-0.5)*2.5, z: (Math.random()-0.5)*12 });
                  if (Math.random() > 0.3) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.0, y: baseY + (Math.random()-0.5)*3.0, z: (Math.random()-0.5)*15 });
                  if (brightness > 150 && Math.random() > 0.4) characterTargets.push({ x: baseX + (Math.random()-0.5)*3.5, y: baseY + (Math.random()-0.5)*3.5, z: (Math.random()-0.5)*18 });
                } else if (!isFace && alpha > 200 && Math.random() > 0.7) {
                  characterTargets.push({ x: baseX + (Math.random()-0.5)*1.5, y: baseY + (Math.random()-0.5)*1.5, z: (Math.random()-0.5)*6 });
                }
              }
            }
          }

          console.log(`ÂæûÂúñÁâáÁîüÊàê ${characterTargets.length} ÂÄãÁõÆÊ®ôÈªû`);
          resolve();
        };

        img.onerror = (e) => {
          console.error("ÂúñÁâáËºâÂÖ•Â§±Êïó:", src, e);
          reject(e);
        };
      });
    }

    function startAnimateLoop() {
      if (rafId) cancelAnimationFrame(rafId);

      const loop = () => {
        if (!animating || !particles) return;

        const p = particles.geometry.attributes.position.array;
        const time = Date.now() * 0.0003;

        const hasTargets = characterTargets.length > 0;

        if (hasTargets) {
          for (let i = 0; i < characterTargets.length && i * 3 < p.length; i++) {
            const idx = i * 3;
            const t = characterTargets[i];
            const breathe = Math.sin(time + i * 0.01) * 0.3;

            p[idx]     += (t.x - p[idx])     * 0.06 * morphStrength;
            p[idx + 1] += (t.y - p[idx + 1]) * 0.06 * morphStrength;
            p[idx + 2] += (t.z + breathe - p[idx + 2]) * 0.06 * morphStrength;
          }
        }

        for (let i = hasTargets ? characterTargets.length : 0; i * 3 < p.length; i++) {
          const idx = i * 3;
          p[idx]     += Math.sin(time + i * 0.1) * 0.04 * (1 - morphStrength);
          p[idx + 1] += Math.cos(time + i * 0.15) * 0.04 * (1 - morphStrength);
          p[idx + 2] += Math.sin(time + i * 0.2) * 0.04 * (1 - morphStrength);
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.002;

        renderer.render(scene, camera3D);
        rafId = requestAnimationFrame(loop);
      };

      rafId = requestAnimationFrame(loop);
    }

    /* ================= FINAL Â∑¶ÈÇä‰∏âÊ†ºÂãïÁï´ÔºàÈÅøÂÖçÈáçË§áÂïüÂãïÔºâ ================= */
    let dnaStarted = false, gridStarted = false, heartStarted = false;

    function startDNA(){
      if (dnaStarted) return;
      dnaStarted = true;

      const c = document.getElementById("dnaCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      let t = 0;
      function loop(){
        ctx.clearRect(0,0,c.width,c.height);
        ctx.strokeStyle = "#7ffcff";
        ctx.lineWidth = 1;

        for(let y=0; y<c.height; y+=3){
          const wave = Math.sin(y*0.05 + t) * 30;
          ctx.beginPath();
          ctx.moveTo(c.width/2 + wave, y);
          ctx.lineTo(c.width/2 - wave, y);
          ctx.stroke();
        }

        t += 0.03;
        requestAnimationFrame(loop);
      }
      loop();
    }

    function startGrid(){
      if (gridStarted) return;
      gridStarted = true;

      const c = document.getElementById("gridCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      const dots = Array.from({length:100},()=>( {
        x: Math.random()*c.width,
        y: Math.random()*c.height,
        a: Math.random()
      }));

      function loop(){
        ctx.clearRect(0,0,c.width,c.height);

        ctx.strokeStyle = "rgba(127,252,255,0.15)";
        for(let x=0;x<c.width;x+=20){
          ctx.beginPath();
          ctx.moveTo(x,0);
          ctx.lineTo(x,c.height);
          ctx.stroke();
        }
        for(let y=0;y<c.height;y+=20){
          ctx.beginPath();
          ctx.moveTo(0,y);
          ctx.lineTo(c.width,y);
          ctx.stroke();
        }

        dots.forEach(d=>{
          d.a += (Math.random()-0.5)*0.1;
          d.a = Math.max(0,Math.min(1,d.a));
          ctx.fillStyle = `rgba(127,252,255,${d.a})`;
          ctx.fillRect(d.x,d.y,2,2);
        });

        requestAnimationFrame(loop);
      }
      loop();
    }

    function startHeartbeat(){
      if (heartStarted) return;
      heartStarted = true;

      const c = document.getElementById("heartCanvas");
      if (!c) return;
      const ctx = c.getContext("2d");

      function resize(){
        c.width = c.clientWidth;
        c.height = c.clientHeight;
      }
      resize();
      window.addEventListener("resize", resize);

      let t = 0;
      function loop(){
        ctx.clearRect(0,0,c.width,c.height);
        ctx.strokeStyle = "#7ffcff";
        ctx.lineWidth = 2;
        ctx.beginPath();

        for(let x=0;x<c.width;x++){
          let y =
            c.height/2 +
            Math.sin((x+t)*0.05)*8 +
            (x%120<10 ? -25 : 0);

          ctx.lineTo(x,y);
        }

        ctx.stroke();
        t += 4;
        requestAnimationFrame(loop);
      }
      loop();
    }

    /* ================= LOADING ================= */
    function startLoadingSequence() {
      const steps=[
        {t:"ÂàùÂßãÂåñ‰∏≠‚Ä¶",p:10},
        {t:"ÂßìÂêçÊ†∏Â∞ç‰∏≠",p:40},
        {t:"Ë≥áÊñôÁ¢∫Ë™ç‰∏≠",p:75},
        {t:"Ê∫ñÂÇôÂÆåÊàê",p:100}
      ];
      let i=0;
      const txt=document.getElementById("loading-text");
      const fill=document.getElementById("progress-fill");
      const per=document.getElementById("progress-percent");

      fill.style.width="0%";
      per.textContent="0%";

      function next(){
        if(i>=steps.length)return;
        txt.textContent=steps[i].t;
        fill.style.width=steps[i].p+"%";
        per.textContent=steps[i].p+"%";
        i++;
        setTimeout(next,600);
      }
      setTimeout(next,150);
    }

    // ================= FINAL ‰∏≠Â§ÆËßíËâ≤ =================
    function initFinalCharacter() {
      if (finalScene) return;

      finalScene = new THREE.Scene();

      finalCamera = new THREE.PerspectiveCamera(50, 1, 1, 1000);
      finalCamera.position.z = 180;

      finalRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      finalRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const container = document.querySelector(".final-center");
      const w = container.clientWidth;
      const h = container.clientHeight;

      finalRenderer.setSize(w, h);
      finalCamera.aspect = w / h;
      finalCamera.updateProjectionMatrix();

      container.innerHTML = "";
      container.appendChild(finalRenderer.domElement);

      loadFinalCharacterPoints("./character.png").then(() => {
        const body = [];
        const face = [];

        finalTargets.forEach(t => {
          if (t.face) face.push(t);
          else body.push(t);
        });

        const bodyPos = new Float32Array(body.length * 3);
        body.forEach((t, i) => {
          bodyPos[i*3]   = t.x + 25;
          bodyPos[i*3+1] = t.y + 40;
          bodyPos[i*3+2] = t.z;
        });

        const bodyGeo = new THREE.BufferGeometry();
        bodyGeo.setAttribute("position", new THREE.BufferAttribute(bodyPos, 3));

        const bodyMat = new THREE.PointsMaterial({
          color: new THREE.Color("#ffffff"),
          size: 0.7,
          transparent: true,
          opacity: 0.55,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const bodyPoints = new THREE.Points(bodyGeo, bodyMat);
        finalScene.add(bodyPoints);

        const facePos = new Float32Array(face.length * 3);
        face.forEach((t, i) => {
          facePos[i*3]   = t.x + 25;
          facePos[i*3+1] = t.y + 40;
          facePos[i*3+2] = t.z;
        });

        const faceGeo = new THREE.BufferGeometry();
        faceGeo.setAttribute("position", new THREE.BufferAttribute(facePos, 3));

        const faceMat = new THREE.PointsMaterial({
          color: new THREE.Color("#ffffff"),
          size: 1.0,
          transparent: true,
          opacity: 0.85,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const facePoints = new THREE.Points(faceGeo, faceMat);
        finalScene.add(facePoints);

        bodyPoints.scale.set(0.35, 0.35, 0.35);
        facePoints.scale.set(0.35, 0.35, 0.35);

        finalParticles = { body: bodyPoints, face: facePoints };

        finalRenderer.render(finalScene, finalCamera);
      });
    }

    function loadFinalCharacterPoints(src) {
      return new Promise(resolve => {
        const img = new Image();
        img.src = src;

        img.onload = () => {
          const c = document.createElement("canvas");
          const ctx = c.getContext("2d");

          const size = 240;
          c.width = size;
          c.height = size;
          ctx.drawImage(img, 0, 0, size, size);

          const data = ctx.getImageData(0, 0, size, size).data;
          finalTargets = [];

          const scale = 220;

          for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
              const i = (y * size + x) * 4;

              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const alpha = data[i + 3];
              const brightness = (r + g + b) / 3;

              if (alpha < 50) continue;

              const px = (x / size - 0.5) * scale;
              const py = -(y / size - 0.5) * scale;

              // üë§ ËáâÈÉ®Âº∑Âåñ
              if (brightness > 165 && alpha > 60) {
                if (Math.random() > 0.1) {
                  finalTargets.push({ x: px, y: py, z: 3, face: true });
                }
                if (Math.random() > 0.6) {
                  finalTargets.push({
                    x: px + (Math.random() - 0.5) * 2,
                    y: py + (Math.random() - 0.5) * 2,
                    z: 4,
                    face: true
                  });
                }
              } else {
                // üßç Ë∫´È´î
                if (Math.random() < 0.22) {
                  finalTargets.push({ x: px, y: py, z: 0, face: false });
                }
              }
            }
          }

          resolve();
        };
      });
    }

    // FINAL ÂãïÁï´ÔºàÂæÆÂëºÂê∏Ôºâ‚Äî ‚úÖ ÂêåÊôÇÂãï body + face
    function startFinalCharacter() {
      stopFinalCharacter();
      finalAnimating = true;

      const loop = () => {
        if (!finalAnimating || !finalParticles) return;

        const t = Date.now() * 0.001;

        [finalParticles.body, finalParticles.face].forEach((obj, layer) => {
          if (!obj) return;
          const p = obj.geometry.attributes.position.array;

          for (let i = 0; i * 3 < p.length; i++) {
            p[i * 3 + 2] += Math.sin(t + i * 0.02 + layer * 0.3) * 0.03;
          }
          obj.geometry.attributes.position.needsUpdate = true;
        });

        finalRenderer.render(finalScene, finalCamera);
        finalRAF = requestAnimationFrame(loop);
      };

      loop();
    }

    function stopFinalCharacter() {
      finalAnimating = false;
      if (finalRAF) {
        cancelAnimationFrame(finalRAF);
        finalRAF = null;
      }
    }

    function switchScreen(state) {
      document.querySelectorAll(".screen").forEach(el=>{
        el.classList.remove("active");
      });

      const target = document.getElementById(state.toLowerCase());
      if (target) target.classList.add("active");
    }

    /* ================= MediaPipe HandsÔºàCOSMOS Â∞àÁî®Ôºâ ================= */
    let hands = null;
    let mpCamera = null;
    let handActive = false;

    function initHands(videoEl) {
      if (hands && mpCamera) return; // ‚úÖ Â∑≤ÂïüÂãïÂ∞±‰∏çË¶ÅÈáçÂª∫

      hands = new Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });

      hands.onResults(results => {
        if (results.multiHandLandmarks?.length) {
          if (!handActive) {
            console.log("‚úã Hand detected");
            handActive = true;
          }
        } else {
          handActive = false;
        }
      });

      mpCamera = new Camera(videoEl, {
        onFrame: async () => {
          await hands.send({ image: videoEl });
        },
        width: 640,
        height: 480
      });

      mpCamera.start();
    }

    // ‚úÖ ÈóúÈçµÔºöÈõ¢Èñã COSMOSÔºàÂéª FINAL / LOADING / IDLEÔºâÊôÇË¶ÅÂÅúÊéâ MediaPipe Camera
    function stopHands() {
      handActive = false;

      if (mpCamera) {
        try { mpCamera.stop(); } catch(e) { /* ignore */ }
        mpCamera = null;
      }

      if (hands) {
        try { hands.close(); } catch(e) { /* ignore */ }
        hands = null;
      }
    }

    /* ================= Firebase ÁãÄÊÖã ================= */
    onValue(ref(db,"runtime/state"), s=>{
      const state = s.val();
      document.getElementById("debug").textContent = `state: ${state}`;
      if (!state) return;

      switchScreen(state);

      if (state === STATES.IDLE) {
        stopFinalCharacter();

        // ‚úÖ ‰∏çÊòØ COSMOS Â∞±ÈóúÊéâ MediaPipe
        stopHands();

        // IDLE Ë¶ÅÈ°ØÁ§∫ÊéÉÊèèÁõ∏Ê©ü
        startCamera();

        // ÂÅúÊ≠¢ COSMOS ÂãïÁï´
        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.LOADING) {
        stopFinalCharacter();

        // ‚úÖ LOADING ‰∏çÁî®Áõ∏Ê©üÔºöÂÖ©Á®ÆÈÉΩÂÅú
        stopHands();
        stopCamera();

        startLoadingSequence();

        animating = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
      }

      else if (state === STATES.COSMOS) {
        stopFinalCharacter();

        // ‚úÖ COSMOSÔºöÁõ∏Ê©ü + ÊâãÂã¢ÂÅµÊ∏¨
        startCamera();
        initHands(video);

        initCosmos();

        animating = true;
        morphStrength = 0;
        setTimeout(() => { morphStrength = 1; }, 1000);

        if (scene && !rafId) startAnimateLoop();
      }

      else if (state === STATES.FINAL) {
        // ‚úÖ FINALÔºöÁõ∏Ê©ü‰∏ÄÂÆöË¶ÅÈóúÔºàÂåÖÂê´ MediaPipe CameraÔºâ
        stopHands();
        stopCamera();

        // ÂÅúÊ≠¢ COSMOS ÂãïÁï´
        animating = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }

        // ÂïüÂãï FINAL ‰∏≠Â§ÆËßíËâ≤
        initFinalCharacter();
        startFinalCharacter();

        // ÂïüÂãïÂ∑¶ÈÇä‰∏âÊ†ºÔºàÂè™ÊúÉË∑ë‰∏ÄÊ¨°Ôºâ
        startDNA();
        startGrid();
        startHeartbeat();

        // Âè≥ÂÅ¥ÊñáÂ≠ó
        document.getElementById("final-title").textContent = "GENETIC PROFILE ¬∑ A01";
        document.getElementById("final-text").textContent =
          "Your biological resonance indicates high adaptability and strong cosmic synchronization.\nFurther evolution recommended.";
      }
    });

    // ================= È°èËâ≤ÂêåÊ≠•ÔºàCOSMOS + FINALÔºâ =================
    onValue(ref(db,"session"), s => {
      const session = s.val();
      if (!session || !session.color) return;

      colorHex = session.color;

      if (particles) {
        particles.material.color.set(colorHex);
      }

      if (finalParticles) {
        finalParticles.body.material.color.set(colorHex);
        finalParticles.face.material.color.set(colorHex);
      }

      console.log("üé® color updated:", colorHex);
    });

    // ===== Ê∏¨Ë©¶ÔºöÂæû GAS ËÆÄË≥áÊñô ‚Üí ÂØ´ÂÖ• Firebase session =====
    async function testLoadSession(id) {
      const res = await fetch(
        "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + id
      );
      const data = await res.json();

      console.log("GAS data:", data);

      if (data && data.id) {
        await set(ref(db, "session"), data);
        console.log("session written:", data);
      }
    }
    window.testLoadSession = testLoadSession;

    // ================= ÊâãÊ©üÊéßÂà∂Êåá‰ª§Áõ£ËÅΩ =================
    onValue(ref(db, "control"), async (s) => {
      const cmd = s.val();
      if (!cmd || !cmd.action) return;

      console.log("üì± control command:", cmd);

      if (cmd.action === "RESET") {
        await set(ref(db, "runtime/state"), STATES.IDLE);
        await set(ref(db, "session"), null);
        return;
      }

      if (cmd.action === "START" && cmd.code) {
        await set(ref(db, "runtime/state"), STATES.LOADING);

        const res = await fetch(
          "https://script.google.com/macros/s/AKfycbySLmfh1u_jqJ3jMXMhu8QTb40of6DPInwxEEYL3-JkvHY1Mel5ViMvVoNeJkBElaJ1Ng/exec?code=" + cmd.code
        );
        const data = await res.json();

        console.log("üìÑ sheet data:", data);

        if (data && data.id) {
          await set(ref(db, "session"), data);
          await set(ref(db, "runtime/state"), STATES.COSMOS);
        }
        return;
      }

      if (cmd.action === "FINAL") {
        await set(ref(db, "runtime/state"), STATES.FINAL);
        return;
      }
    });
  </script>
</body>
</html>
